<!--
  Generated by LLM Code Printer
  Date: 2025-10-26T07:55:51.097Z
  Part: 1 of 1
  Files: 1-26
-->

# MikaBooM_CPP

## 项目信息

- **项目名称**: MikaBooM_CPP
- **生成时间**: 2025/10/26 15:55:51
- **文件总数**: 26
- **压缩模式**: 标准压缩

> ⚠️ **注意**: 代码已压缩，使用时请先格式化

## 目录结构

```tree
E:\项目\Github\MikaBooM_CPP/
res/
  resource.rc
src/
  core/
    config_manager.cpp
    config_manager.h
    cpu_worker.cpp
    cpu_worker.h
    ema_filter.h
    memory_worker.cpp
    memory_worker.h
    pid_controller.h
    resource_monitor.cpp
    resource_monitor.h
  platform/
    autostart.cpp
    autostart.h
    system_tray.cpp
    system_tray.h
  utils/
    console_utils.cpp
    console_utils.h
    system_info.h
    version.cpp
    version.h
  main.cpp
.gitignore
config.ini
Makefile
Makefile.msvc
README.md
```

## 代码文件

### 1. res\resource.rc

```text
#include <windows.h>
1 VERSIONINFO
FILEVERSION    1,0,0,0
PRODUCTVERSION 1,0,0,0
FILEFLAGSMASK  0x3F
FILEFLAGS      0x0
FILEOS         VOS_NT_WINDOWS32
FILETYPE       VFT_APP
FILESUBTYPE    0x0
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904B0"
        BEGIN
            VALUE "CompanyName",      "Makoto Studio"
            VALUE "FileDescription",  "MikaBooM Resource Monitor"
            VALUE "FileVersion",      "1.0.0.0"
            VALUE "InternalName",     "MikaBooM"
            VALUE "LegalCopyright",   "Copyright (C) 2025 Makoto"
            VALUE "OriginalFilename", "MikaBooM.exe"
            VALUE "ProductName",      "MikaBooM C++ Edition"
            VALUE "ProductVersion",   "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END
// 图标资源
IDI_MAIN ICON "icon.ico"
```

### 2. src\core\config_manager.cpp

```cpp
#include "config_manager.h"
#include <windows.h>
#include <fstream>
#include <sstream>
#include <algorithm>
ConfigManager::ConfigManager() : enableWorker(true) {
SetDefaults(); configPath = GetExePath() + "\\config.ini"; }
ConfigManager::~ConfigManager() {
Save(); }
void ConfigManager::SetDefaults() {
cpuThreshold = 70; memoryThreshold = 70; autoStart = true; showWindow = true; updateInterval = 2; notificationEnabled = true; notificationCooldown = 60; }
std::string ConfigManager::GetExePath() {
char buffer[MAX_PATH]; GetModuleFileNameA(NULL, buffer, MAX_PATH); std::string path(buffer); size_t pos = path.find_last_of("\\/");
return path.substr(0, pos); }
void ConfigManager::Load() {
std::ifstream file(configPath);
if (!file.is_open()) {
Save();
return; }
std::string line;
while (std::getline(file, line)) {
ParseLine(line); }
file.close(); }
void ConfigManager::Save() {
std::ofstream file(configPath);
if (!file.is_open()) return; file << "; MikaBooM Configuration File\n"; file << "; Generated by MikaBooM C++ Edition\n\n"; file << "[General]\n"; file << "cpu_threshold=" << cpuThreshold << "\n"; file << "memory_threshold=" << memoryThreshold << "\n"; file << "auto_start=" << (autoStart ? "true" : "false") << "\n"; file << "show_window=" << (showWindow ? "true" : "false") << "\n"; file << "update_interval=" << updateInterval << "\n\n"; file << "[Notification]\n"; file << "enabled=" << (notificationEnabled ? "true" : "false") << "\n"; file << "cooldown=" << notificationCooldown << "\n"; file.close(); }
void ConfigManager::ParseLine(const std::string& line) {
if (line.empty() || line[0] == ';' || line[0] == '[') return; size_t pos = line.find('=');
if (pos == std::string::npos) return; std::string key = Trim(line.substr(0, pos)); std::string value = Trim(line.substr(pos + 1));
if (key == "cpu_threshold") cpuThreshold = std::stoi(value);
else if (key == "memory_threshold") memoryThreshold = std::stoi(value);
else if (key == "auto_start") autoStart = (value == "true");
else if (key == "show_window") showWindow = (value == "true");
else if (key == "update_interval") updateInterval = std::stoi(value);
else if (key == "enabled") notificationEnabled = (value == "true");
else if (key == "cooldown") notificationCooldown = std::stoi(value); }
std::string ConfigManager::Trim(const std::string& str) {
size_t first = str.find_first_not_of(" \t\r\n"); size_t last = str.find_last_not_of(" \t\r\n");
if (first == std::string::npos) return "";
return str.substr(first, (last - first + 1)); }
void ConfigManager::SetConfigPath(const std::string& path) {
configPath = path; Load(); }
```

### 3. src\core\config_manager.h

```c
#pragma once
#include <string>
#include <map>
class ConfigManager {
private:
std::string configPath; std::map<std::string, std::string> config; int cpuThreshold; int memoryThreshold; bool autoStart; bool showWindow; int updateInterval; bool notificationEnabled; int notificationCooldown; bool enableWorker;
public:
ConfigManager(); ~ConfigManager(); void Load(); void Save(); void SetConfigPath(const std::string& path); int GetCPUThreshold() const { return cpuThreshold; }
int GetMemoryThreshold() const { return memoryThreshold; }
bool GetAutoStart() const { return autoStart; }
bool GetShowWindow() const { return showWindow; }
int GetUpdateInterval() const { return updateInterval; }
bool GetNotificationEnabled() const { return notificationEnabled; }
int GetNotificationCooldown() const { return notificationCooldown; }
bool GetEnableWorker() const { return enableWorker; }
void SetCPUThreshold(int value) { cpuThreshold = value; }
void SetMemoryThreshold(int value) { memoryThreshold = value; }
void SetAutoStart(bool value) { autoStart = value; }
void SetShowWindow(bool value) { showWindow = value; }
void SetUpdateInterval(int value) { updateInterval = value; }
void SetNotificationEnabled(bool value) { notificationEnabled = value; }
void SetNotificationCooldown(int value) { notificationCooldown = value; }
void SetEnableWorker(bool value) { enableWorker = value; }
private:
void SetDefaults(); std::string GetExePath(); void ParseLine(const std::string& line); std::string Trim(const std::string& str); };
```

### 4. src\core\cpu_worker.cpp

```cpp
#include "cpu_worker.h"
#include <cmath>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
CPUWorker::CPUWorker(int thresh)
: threshold(thresh), running(0), intensity(30), lastAdjustTime(0) {
SYSTEM_INFO sysInfo; GetSystemInfo(&sysInfo); numWorkers = sysInfo.dwNumberOfProcessors; InitializeCriticalSection(&adjustLock); }
CPUWorker::~CPUWorker() {
Stop(); DeleteCriticalSection(&adjustLock); }
void CPUWorker::Start() {
if (InterlockedCompareExchange(&running, 1, 0) != 0) return; InterlockedExchange(&intensity, 30); lastAdjustTime = GetTickCount(); workers.clear();
for (int i = 0; i < numWorkers; i++) {
HANDLE hThread = CreateThread(NULL, 0, WorkerThreadProc, this, 0, NULL);
if (hThread) {
SetThreadPriority(hThread, THREAD_PRIORITY_BELOW_NORMAL); workers.push_back(hThread); }
}
}
void CPUWorker::Stop() {
if (InterlockedCompareExchange(&running, 0, 1) != 1) return;
if (!workers.empty()) {
WaitForMultipleObjects(workers.size(), &workers[0], TRUE, 5000);
for (size_t i = 0; i < workers.size(); i++) {
CloseHandle(workers[i]); }
}
workers.clear(); InterlockedExchange(&intensity, 0); }
DWORD WINAPI CPUWorker::WorkerThreadProc(LPVOID lpParam) {
CPUWorker* self = (CPUWorker*)lpParam; self->WorkerThread();
return 0; }
void CPUWorker::WorkerThread() {
while (running) {
LONG currentIntensity = intensity; DWORD workDuration = currentIntensity; DWORD sleepDuration = 100 - currentIntensity;
if (workDuration > 0) {
DWORD startTime = GetTickCount();
while (GetTickCount() - startTime < workDuration && running) {
DoWork(currentIntensity); }
}
if (sleepDuration > 0 && running) {
Sleep(sleepDuration); }
}
}
void CPUWorker::DoWork(int intensityLevel) {
volatile double result = 0;
for (int i = 0; i < 1000; i++) {
result += pow(-1.0, i) / (2.0 * i + 1.0); }
volatile double piApprox = result * 4.0;
for (int i = 0; i < 100; i++) {
double angle = i * 0.1; result += sin(angle) * cos(angle) * tan(angle); }
volatile double matrix[10][10];
for (int i = 0; i < 10; i++) {
for (int j = 0; j < 10; j++) {
matrix[i][j] = i * j * sin(i + j); }
}
for (int i = 1; i < 100; i++) {
result += log((double)i) * exp((double)(i % 10)); }
for (int i = 1; i < 100; i++) {
result += sqrt((double)i) * pow((double)i, 1.5); }
(void)piApprox; (void)matrix; }
double CPUWorker::GetUsage() const {
if (!running) return 0; double estimatedUsage = (intensity / 100.0) * numWorkers * 100.0 / numWorkers;
if (estimatedUsage > 100) estimatedUsage = 100;
return estimatedUsage; }
void CPUWorker::AdjustLoad(double currentWorkerUsage, double targetWorkerUsage) {
if (!running) return; EnterCriticalSection(&adjustLock); DWORD now = GetTickCount();
if (now - lastAdjustTime < 500) {
LeaveCriticalSection(&adjustLock);
return; }
lastAdjustTime = now; double diff = targetWorkerUsage - currentWorkerUsage; LONG currentIntensity = intensity; LONG newIntensity = currentIntensity;
if (diff > 20) {
newIntensity += 10; } else if (diff > 10) {
newIntensity += 5; } else if (diff > 5) {
newIntensity += 3; } else if (diff > 2) {
newIntensity += 2; } else if (diff > 0.5) {
newIntensity += 1; } else if (diff < -20) {
newIntensity -= 10; } else if (diff < -10) {
newIntensity -= 5; } else if (diff < -5) {
newIntensity -= 3; } else if (diff < -2) {
newIntensity -= 2; } else if (diff < -0.5) {
newIntensity -= 1; }
if (newIntensity < 0) newIntensity = 0;
if (newIntensity > 100) newIntensity = 100; InterlockedExchange(&intensity, newIntensity); LeaveCriticalSection(&adjustLock); }
```

### 5. src\core\cpu_worker.h

```c
#pragma once
#include <windows.h>
#include <vector>
class CPUWorker {
private:
int threshold; volatile LONG running; volatile LONG intensity; std::vector<HANDLE> workers; int numWorkers; DWORD lastAdjustTime; CRITICAL_SECTION adjustLock;
public:
CPUWorker(int threshold); ~CPUWorker(); void Start(); void Stop(); bool IsRunning() const { return running != 0; }
void AdjustLoad(double currentWorkerUsage, double targetWorkerUsage); int GetIntensity() const { return intensity; }
double GetUsage() const;
private:
static DWORD WINAPI WorkerThreadProc(LPVOID lpParam); void WorkerThread(); void DoWork(int intensityLevel); };
```

### 6. src\core\ema_filter.h

```c
#pragma once
class EMAFilter {
private:
double alpha; double value; bool initialized;
public:
EMAFilter(double smoothFactor = 0.3)
: alpha(smoothFactor), value(0), initialized(false) {
}
double Update(double newValue) {
if (!initialized) {
value = newValue; initialized = true; } else {
value = alpha * newValue + (1.0 - alpha) * value; }
return value; }
double GetValue() const {
return value; }
void Reset() {
value = 0; initialized = false; }
void SetSmoothFactor(double factor) {
if (factor >= 0 && factor <= 1) {
alpha = factor; }
}
};
```

### 7. src\core\memory_worker.cpp

```cpp
#include "memory_worker.h"
#include "../utils/system_info.h"
MemoryWorker::MemoryWorker(int thresh)
: threshold(thresh), running(0), targetSizeMB(0), totalMemoryBytes(16LL * 1024 * 1024 * 1024), workerThread(NULL), lastAdjustTime(0) {
InitializeCriticalSection(&allocLock); }
MemoryWorker::~MemoryWorker() {
Stop(); DeleteCriticalSection(&allocLock); }
void MemoryWorker::Start() {
if (InterlockedCompareExchange(&running, 1, 0) != 0) return; InterlockedExchange(&targetSizeMB, 0); lastAdjustTime = GetTickCount(); workerThread = CreateThread(NULL, 0, WorkerThreadProc, this, 0, NULL); }
void MemoryWorker::Stop() {
if (InterlockedCompareExchange(&running, 0, 1) != 1) return;
if (workerThread) {
WaitForSingleObject(workerThread, 5000); CloseHandle(workerThread); workerThread = NULL; }
EnterCriticalSection(&allocLock);
for (size_t i = 0; i < allocatedMemory.size(); i++) {
VirtualFree(allocatedMemory[i], 0, MEM_RELEASE); }
allocatedMemory.clear(); LeaveCriticalSection(&allocLock); InterlockedExchange(&targetSizeMB, 0); }
DWORD WINAPI MemoryWorker::WorkerThreadProc(LPVOID lpParam) {
MemoryWorker* self = (MemoryWorker*)lpParam; self->WorkerLoop();
return 0; }
void MemoryWorker::WorkerLoop() {
while (running) {
int64_t targetBytes = (int64_t)targetSizeMB * 1024 * 1024; int64_t currentBytes = GetAllocatedSize(); int64_t diff = targetBytes - currentBytes;
if (diff > 0) {
AllocateMemory(diff); } else if (diff < 0) {
FreeMemory(-diff); }
Sleep(1000); }
}
void MemoryWorker::AllocateMemory(int64_t sizeBytes) {
DWORD major, minor; SystemInfo::GetRealWindowsVersion(major, minor);
const int64_t chunkSize = 10LL * 1024 * 1024; int64_t actualChunkSize = (major >= 6) ? chunkSize : (5LL * 1024 * 1024); int64_t chunks = sizeBytes / actualChunkSize; EnterCriticalSection(&allocLock);
for (int64_t i = 0; i < chunks && running; i++) {
void* chunk = VirtualAlloc(NULL, actualChunkSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (chunk) {
for (size_t j = 0; j < (size_t)actualChunkSize; j += 4096) {
((char*)chunk)[j] = (char)(j % 256); }
allocatedMemory.push_back(chunk); } else {
break; }
if (major < 6) {
Sleep(10); }
}
int64_t remainder = sizeBytes % actualChunkSize;
if (remainder > 0 && running) {
void* chunk = VirtualAlloc(NULL, remainder, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (chunk) {
for (size_t j = 0; j < (size_t)remainder; j += 4096) {
((char*)chunk)[j] = (char)(j % 256); }
allocatedMemory.push_back(chunk); }
}
LeaveCriticalSection(&allocLock); }
void MemoryWorker::FreeMemory(int64_t sizeBytes) {
int64_t freed = 0; EnterCriticalSection(&allocLock);
while (freed < sizeBytes && !allocatedMemory.empty()) {
void* ptr = allocatedMemory.back(); allocatedMemory.pop_back(); MEMORY_BASIC_INFORMATION mbi;
if (VirtualQuery(ptr, &mbi, sizeof(mbi))) {
freed += mbi.RegionSize; VirtualFree(ptr, 0, MEM_RELEASE); }
}
LeaveCriticalSection(&allocLock); }
int64_t MemoryWorker::GetAllocatedSize() const {
int64_t total = 0; EnterCriticalSection((LPCRITICAL_SECTION)&allocLock);
for (size_t i = 0; i < allocatedMemory.size(); i++) {
MEMORY_BASIC_INFORMATION mbi;
if (VirtualQuery(allocatedMemory[i], &mbi, sizeof(mbi))) {
total += mbi.RegionSize; }
}
LeaveCriticalSection((LPCRITICAL_SECTION)&allocLock);
return total; }
double MemoryWorker::GetUsage() const {
if (!running || totalMemoryBytes == 0) return 0; int64_t allocated = GetAllocatedSize(); double usage = (double)allocated / totalMemoryBytes * 100.0;
if (usage > 100) usage = 100;
return usage; }
void MemoryWorker::AdjustLoad(double currentWorkerUsage, double targetWorkerUsage) {
if (!running) return; DWORD now = GetTickCount();
if (now - lastAdjustTime < 2000) {
return; }
lastAdjustTime = now; int64_t targetBytes = (int64_t)(totalMemoryBytes * targetWorkerUsage / 100.0); int64_t maxBytes = (int64_t)(totalMemoryBytes * 0.8);
if (targetBytes > maxBytes) targetBytes = maxBytes; int64_t currentBytes = GetAllocatedSize(); int64_t maxAdjust = 512LL * 1024 * 1024;
if (targetBytes > currentBytes + maxAdjust) {
targetBytes = currentBytes + maxAdjust; } else if (targetBytes < currentBytes - maxAdjust) {
targetBytes = currentBytes - maxAdjust; }
if (targetBytes < 0) targetBytes = 0; InterlockedExchange(&targetSizeMB, (LONG)(targetBytes / (1024 * 1024))); }
```

### 8. src\core\memory_worker.h

```c
#pragma once
#include <windows.h>
#include <vector>
#include <stdint.h>
class MemoryWorker {
private:
int threshold; volatile LONG running; std::vector<void*> allocatedMemory; volatile LONG targetSizeMB; int64_t totalMemoryBytes; HANDLE workerThread; DWORD lastAdjustTime; CRITICAL_SECTION allocLock;
public:
MemoryWorker(int threshold); ~MemoryWorker(); void Start(); void Stop(); bool IsRunning() const { return running != 0; }
void AdjustLoad(double currentWorkerUsage, double targetWorkerUsage); int64_t GetAllocatedSize() const; int64_t GetTargetSize() const { return targetSizeMB * 1024LL * 1024LL; }
double GetUsage() const; void SetTotalMemory(uint64_t total) { totalMemoryBytes = total; }
private:
static DWORD WINAPI WorkerThreadProc(LPVOID lpParam); void WorkerLoop(); void AllocateMemory(int64_t sizeBytes); void FreeMemory(int64_t sizeBytes); };
```

### 9. src\core\pid_controller.h

```c
#pragma once
class PIDController {
private:
double kp; double ki; double kd; double lastError; double integral; double setpoint; double minOutput; double maxOutput; double integralMax;
public:
PIDController(double p, double i, double d)
: kp(p), ki(i), kd(d), lastError(0), integral(0), setpoint(0), minOutput(0), maxOutput(100), integralMax(50) {
}
void SetTarget(double target) {
setpoint = target; }
void SetOutputLimits(double min, double max) {
minOutput = min; maxOutput = max; }
double Compute(double current, double deltaTime) {
double error = setpoint - current; integral += error * deltaTime;
if (integral > integralMax) integral = integralMax;
if (integral < -integralMax) integral = -integralMax; double derivative = (error - lastError) / deltaTime; double output = kp * error + ki * integral + kd * derivative;
if (output < minOutput) output = minOutput;
if (output > maxOutput) output = maxOutput; lastError = error;
return output; }
void Reset() {
lastError = 0; integral = 0; }
void Tune(double p, double i, double d) {
kp = p; ki = i; kd = d; }
};
```

### 10. src\core\resource_monitor.cpp

```cpp
#include "resource_monitor.h"
#include <iostream>
ResourceMonitor::ResourceMonitor()
: pGetSystemTimes(NULL), useGetSystemTimes(false), hQuery(NULL), hCounter(NULL), usePDH(false), lastPdhCollectTime(0), majorVersion(5), minorVersion(0), lastCPUValue(-1.0), lastMemValue(-1.0), stableCPUCount(0), stableMemCount(0) {
SYSTEM_INFO sysInfo; ::GetSystemInfo(&sysInfo); numProcessors = sysInfo.dwNumberOfProcessors; self = GetCurrentProcess(); DetectWindowsVersion(); InitCPU(); }
ResourceMonitor::~ResourceMonitor() {
CleanupPDH(); }
void ResourceMonitor::DetectWindowsVersion() {
OSVERSIONINFOEXA osvi; ZeroMemory(&osvi, sizeof(OSVERSIONINFOEXA)); osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA); typedef LONG (WINAPI* RtlGetVersionPtr)(PRTL_OSVERSIONINFOEXW); HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
if (hNtdll) {
RtlGetVersionPtr pRtlGetVersion = (RtlGetVersionPtr)GetProcAddress(hNtdll, "RtlGetVersion");
if (pRtlGetVersion) {
OSVERSIONINFOEXW osviW; ZeroMemory(&osviW, sizeof(osviW)); osviW.dwOSVersionInfoSize = sizeof(osviW);
if (pRtlGetVersion((PRTL_OSVERSIONINFOEXW)&osviW) == 0) {
majorVersion = osviW.dwMajorVersion; minorVersion = osviW.dwMinorVersion;
return; }
}
}
if (GetVersionExA((LPOSVERSIONINFOA)&osvi)) {
majorVersion = osvi.dwMajorVersion; minorVersion = osvi.dwMinorVersion; }
}
double ResourceMonitor::SmoothValue(double newValue, double lastValue, double alpha) {
if (lastValue < 0) return newValue;
return alpha * newValue + (1.0 - alpha) * lastValue; }
void ResourceMonitor::InitCPU() {
HMODULE hKernel32 = GetModuleHandleA("kernel32.dll");
if (hKernel32) {
pGetSystemTimes = (PGetSystemTimes)GetProcAddress(hKernel32, "GetSystemTimes");
if (pGetSystemTimes) {
useGetSystemTimes = true; FILETIME idleTime, kernelTime, userTime; pGetSystemTimes(&idleTime, &kernelTime, &userTime); memcpy(&lastIdleTime, &idleTime, sizeof(FILETIME)); memcpy(&lastKernelTime, &kernelTime, sizeof(FILETIME)); memcpy(&lastUserTime, &userTime, sizeof(FILETIME));
return; }
}
useGetSystemTimes = false; usePDH = false; PDH_STATUS status = PdhOpenQueryA(NULL, 0, &hQuery);
if (status != ERROR_SUCCESS) {
return; }
status = PdhAddCounterA(hQuery, "\\Processor(_Total)\\% Processor Time", 0, &hCounter);
if (status != ERROR_SUCCESS) {
PdhCloseQuery(hQuery); hQuery = NULL;
return; }
for (int i = 0; i < 3; i++) {
PdhCollectQueryData(hQuery); Sleep(100); }
usePDH = true; lastPdhCollectTime = GetTickCount(); }
void ResourceMonitor::CleanupPDH() {
if (hCounter) {
PdhRemoveCounter(hCounter); hCounter = NULL; }
if (hQuery) {
PdhCloseQuery(hQuery); hQuery = NULL; }
}
double ResourceMonitor::GetCPUUsage() {
double rawValue;
if (useGetSystemTimes) {
rawValue = GetCPUUsageViaSystemTimes(); } else {
rawValue = GetCPUUsageViaPDH(); }
double alpha = (majorVersion >= 6) ? 0.3 : 0.15; rawValue = SmoothValue(rawValue, lastCPUValue, alpha); lastCPUValue = rawValue;
return rawValue; }
double ResourceMonitor::GetCPUUsageViaSystemTimes() {
FILETIME idleTime, kernelTime, userTime; ULARGE_INTEGER idle, kernel, user; pGetSystemTimes(&idleTime, &kernelTime, &userTime); memcpy(&idle, &idleTime, sizeof(FILETIME)); memcpy(&kernel, &kernelTime, sizeof(FILETIME)); memcpy(&user, &userTime, sizeof(FILETIME)); ULONGLONG idleDiff = idle.QuadPart - lastIdleTime.QuadPart; ULONGLONG kernelDiff = kernel.QuadPart - lastKernelTime.QuadPart; ULONGLONG userDiff = user.QuadPart - lastUserTime.QuadPart; ULONGLONG totalDiff = kernelDiff + userDiff; double cpuUsage = 0.0;
if (totalDiff > 0) {
cpuUsage = (double)(totalDiff - idleDiff) / totalDiff * 100.0; }
lastIdleTime = idle; lastKernelTime = kernel; lastUserTime = user;
if (cpuUsage < 0.0) cpuUsage = 0.0;
if (cpuUsage > 100.0) cpuUsage = 100.0;
return cpuUsage; }
double ResourceMonitor::GetCPUUsageViaPDH() {
if (!usePDH || !hQuery || !hCounter) {
return lastCPUValue > 0 ? lastCPUValue : 0.0; }
DWORD currentTime = GetTickCount(); DWORD elapsed = currentTime - lastPdhCollectTime;
if (elapsed < 500) {
return lastCPUValue > 0 ? lastCPUValue : 0.0; }
PDH_STATUS status = PdhCollectQueryData(hQuery);
if (status != ERROR_SUCCESS) {
return lastCPUValue > 0 ? lastCPUValue : 0.0; }
lastPdhCollectTime = currentTime; PDH_FMT_COUNTERVALUE counterValue; status = PdhGetFormattedCounterValue(hCounter, PDH_FMT_DOUBLE, NULL, &counterValue);
if (status != ERROR_SUCCESS) {
return lastCPUValue > 0 ? lastCPUValue : 0.0; }
double cpuUsage = counterValue.doubleValue;
if (cpuUsage < 0.0) cpuUsage = 0.0;
if (cpuUsage > 100.0) cpuUsage = 100.0;
return cpuUsage; }
double ResourceMonitor::GetMemoryUsage() {
MEMORYSTATUSEX memInfo; memInfo.dwLength = sizeof(MEMORYSTATUSEX);
if (GlobalMemoryStatusEx(&memInfo)) {
DWORDLONG totalPhysMem = memInfo.ullTotalPhys; DWORDLONG physMemUsed = totalPhysMem - memInfo.ullAvailPhys; double rawValue = (double)physMemUsed / totalPhysMem * 100.0; double alpha = (majorVersion >= 6) ? 0.3 : 0.15; rawValue = SmoothValue(rawValue, lastMemValue, alpha); lastMemValue = rawValue;
return rawValue; }
return lastMemValue > 0 ? lastMemValue : 0.0; }
MEMORYSTATUSEX ResourceMonitor::GetMemoryInfo() {
MEMORYSTATUSEX memInfo; memInfo.dwLength = sizeof(MEMORYSTATUSEX); GlobalMemoryStatusEx(&memInfo);
return memInfo; }
SYSTEM_INFO ResourceMonitor::GetSysInfo() {
SYSTEM_INFO sysInfo; ::GetSystemInfo(&sysInfo);
return sysInfo; }
```

### 11. src\core\resource_monitor.h

```c
#pragma once
#include <windows.h>
#include <psapi.h>
#include <pdh.h>
#include <string>
class ResourceMonitor {
private:
ULARGE_INTEGER lastIdleTime; ULARGE_INTEGER lastKernelTime; ULARGE_INTEGER lastUserTime; int numProcessors; HANDLE self; typedef BOOL (WINAPI *PGetSystemTimes)(LPFILETIME, LPFILETIME, LPFILETIME); PGetSystemTimes pGetSystemTimes; bool useGetSystemTimes; PDH_HQUERY hQuery; PDH_HCOUNTER hCounter; bool usePDH; DWORD lastPdhCollectTime; DWORD majorVersion; DWORD minorVersion; double lastCPUValue; double lastMemValue; int stableCPUCount; int stableMemCount; double SmoothValue(double newValue, double lastValue, double alpha = 0.3);
public:
ResourceMonitor(); ~ResourceMonitor(); double GetCPUUsage(); double GetMemoryUsage(); MEMORYSTATUSEX GetMemoryInfo(); SYSTEM_INFO GetSysInfo();
private:
void InitCPU(); double GetCPUUsageViaSystemTimes(); double GetCPUUsageViaPDH(); void CleanupPDH(); void DetectWindowsVersion(); };
```

### 12. src\platform\autostart.cpp

```cpp
#include "autostart.h"
#include <windows.h>
const char* AutoStart::GetRegistryKey() {
return "Software\\Microsoft\\Windows\\CurrentVersion\\Run"; }
std::string AutoStart::GetExePath() {
char buffer[MAX_PATH]; GetModuleFileNameA(NULL, buffer, MAX_PATH);
return std::string(buffer); }
bool AutoStart::Enable() {
HKEY hKey; std::string exePath = GetExePath() + " -window=false";
if (RegOpenKeyExA(HKEY_CURRENT_USER, GetRegistryKey(), 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
LONG result = RegSetValueExA(hKey, "MikaBooM", 0, REG_SZ, (const BYTE*)exePath.c_str(), (DWORD)exePath.length() + 1); RegCloseKey(hKey);
return result == ERROR_SUCCESS; }
return false; }
bool AutoStart::Disable() {
HKEY hKey;
if (RegOpenKeyExA(HKEY_CURRENT_USER, GetRegistryKey(), 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
LONG result = RegDeleteValueA(hKey, "MikaBooM"); RegCloseKey(hKey);
return result == ERROR_SUCCESS || result == ERROR_FILE_NOT_FOUND; }
return false; }
bool AutoStart::IsEnabled() {
HKEY hKey;
if (RegOpenKeyExA(HKEY_CURRENT_USER, GetRegistryKey(), 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
DWORD type; DWORD size = 0; LONG result = RegQueryValueExA(hKey, "MikaBooM", NULL, &type, NULL, &size); RegCloseKey(hKey);
return result == ERROR_SUCCESS; }
return false; }
```

### 13. src\platform\autostart.h

```c
#pragma once
#include <string>
class AutoStart {
public:
static bool Enable(); static bool Disable(); static bool IsEnabled();
private:
static std::string GetExePath(); static const char* GetRegistryKey(); };
```

### 14. src\platform\system_tray.cpp

```cpp
#include "system_tray.h"
#include "../platform/autostart.h"
#include "../utils/system_info.h"
#include <cstring>
extern volatile LONG g_running; extern volatile LONG g_show_window; SystemTray* SystemTray::instance = nullptr; SystemTray::SystemTray() : hwnd(NULL), hMenu(NULL) {
instance = this; memset(&nid, 0, sizeof(nid)); }
SystemTray::~SystemTray() {
Destroy(); instance = nullptr; }
bool SystemTray::Create() {
WNDCLASSEXA wc = {0}; wc.cbSize = sizeof(WNDCLASSEXA); wc.lpfnWndProc = WindowProc; wc.hInstance = GetModuleHandle(NULL); wc.lpszClassName = "MikaBooMTrayClass";
if (!RegisterClassExA(&wc)) {
return false; }
hwnd = CreateWindowExA(0, "MikaBooMTrayClass", "MikaBooM", 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, GetModuleHandle(NULL), NULL);
if (!hwnd) {
return false; }
nid.cbSize = sizeof(NOTIFYICONDATAA); nid.hWnd = hwnd; nid.uID = 1; nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE; nid.uCallbackMessage = WM_TRAYICON; nid.hIcon = LoadIcon(NULL, IDI_APPLICATION); strncpy(nid.szTip, "MikaBooM - Resource Monitor", sizeof(nid.szTip) - 1); nid.szTip[sizeof(nid.szTip) - 1] = '\0'; Shell_NotifyIconA(NIM_ADD, &nid); CreateTrayMenu();
return true; }
void SystemTray::Destroy() {
if (nid.hWnd) {
Shell_NotifyIconA(NIM_DELETE, &nid); }
if (hMenu) {
DestroyMenu(hMenu); hMenu = NULL; }
if (hwnd) {
DestroyWindow(hwnd); hwnd = NULL; }
UnregisterClassA("MikaBooMTrayClass", GetModuleHandle(NULL)); }
void SystemTray::UpdateTooltip(const char* text) {
if (strlen(text) < sizeof(nid.szTip)) {
strncpy(nid.szTip, text, sizeof(nid.szTip) - 1); nid.szTip[sizeof(nid.szTip) - 1] = '\0'; Shell_NotifyIconA(NIM_MODIFY, &nid); }
}
void SystemTray::ShowBalloon(const char* title, const char* text) {
NOTIFYICONDATAA nid_balloon = nid; nid_balloon.uFlags |= NIF_INFO; nid_balloon.dwInfoFlags = NIIF_INFO;
if (strlen(title) < sizeof(nid_balloon.szInfoTitle)) {
strncpy(nid_balloon.szInfoTitle, title, sizeof(nid_balloon.szInfoTitle) - 1); nid_balloon.szInfoTitle[sizeof(nid_balloon.szInfoTitle) - 1] = '\0'; }
if (strlen(text) < sizeof(nid_balloon.szInfo)) {
strncpy(nid_balloon.szInfo, text, sizeof(nid_balloon.szInfo) - 1); nid_balloon.szInfo[sizeof(nid_balloon.szInfo) - 1] = '\0'; }
Shell_NotifyIconA(NIM_MODIFY, &nid_balloon); }
void SystemTray::CreateTrayMenu() {
if (hMenu) {
DestroyMenu(hMenu); }
hMenu = CreatePopupMenu(); AppendMenuA(hMenu, MF_STRING, ID_TRAY_SHOW, g_show_window ? "Hide &Window" : "&Show Window"); AppendMenuA(hMenu, MF_STRING | (AutoStart::IsEnabled() ? MF_CHECKED : 0), ID_TRAY_AUTOSTART, "&Auto Start"); AppendMenuA(hMenu, MF_SEPARATOR, 0, NULL); AppendMenuA(hMenu, MF_STRING, ID_TRAY_EXIT, "E&xit"); }
LRESULT CALLBACK SystemTray::WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
switch (msg) {
case WM_TRAYICON:
if (instance) {
instance->OnTrayIcon(lParam); }
break;
case WM_COMMAND:
switch (LOWORD(wParam)) {
case ID_TRAY_EXIT:
InterlockedExchange(&g_running, 0);
break;
case ID_TRAY_SHOW:
if (g_show_window) {
FreeConsole(); InterlockedExchange(&g_show_window, 0); } else {
AllocConsole(); freopen("CONOUT$", "w", stdout); freopen("CONOUT$", "w", stderr); freopen("CONIN$", "r", stdin); InterlockedExchange(&g_show_window, 1); }
if (instance) {
instance->CreateTrayMenu(); }
break;
case ID_TRAY_AUTOSTART:
if (AutoStart::IsEnabled()) {
AutoStart::Disable(); } else {
AutoStart::Enable(); }
if (instance) {
instance->CreateTrayMenu(); }
break; }
break; default:
return DefWindowProc(hwnd, msg, wParam, lParam); }
return 0; }
void SystemTray::OnTrayIcon(LPARAM lParam) {
if (lParam == WM_RBUTTONUP) {
POINT pt; GetCursorPos(&pt); CreateTrayMenu(); SetForegroundWindow(hwnd); TrackPopupMenu(hMenu, TPM_RIGHTBUTTON, pt.x, pt.y, 0, hwnd, NULL); PostMessage(hwnd, WM_NULL, 0, 0); }
}
```

### 15. src\platform\system_tray.h

```c
#pragma once
#include <windows.h>
#include <shellapi.h>
#include <string>
#define WM_TRAYICON (WM_USER + 1)
#define ID_TRAY_EXIT 1001
#define ID_TRAY_SHOW 1002
#define ID_TRAY_AUTOSTART 1003
class SystemTray {
private:
HWND hwnd; NOTIFYICONDATAA nid; HMENU hMenu; static SystemTray* instance;
public:
SystemTray(); ~SystemTray(); bool Create(); void Destroy(); void UpdateTooltip(const char* text); void ShowBalloon(const char* title, const char* text);
private:
static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); void CreateTrayMenu(); void OnTrayIcon(LPARAM lParam); };
```

### 16. src\utils\console_utils.cpp

```cpp
#include "console_utils.h"
#include "version.h"
#include "system_info.h"
#include <cstdio>
#include <cstdarg>
#include <ctime>
#include <cstring>
static HANDLE hConsole = NULL; static WORD originalAttributes = 7; static bool isInitialized = false; bool ConsoleUtils::useUTF8 = false; void ConsoleUtils::Init() {
if (isInitialized) return; hConsole = GetStdHandle(STD_OUTPUT_HANDLE); CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
if (GetConsoleScreenBufferInfo(hConsole, &consoleInfo)) {
originalAttributes = consoleInfo.wAttributes; }
useUTF8 = IsWindows7OrLater();
if (useUTF8) {
SetConsoleCP(65001); SetConsoleOutputCP(65001); } else {
SetConsoleCP(437); SetConsoleOutputCP(437); }
Version::InitAsciiArt(useUTF8); isInitialized = true; }
bool ConsoleUtils::IsWindows7OrLater() {
return SystemInfo::IsWindows7OrLater(); }
void ConsoleUtils::SetColor(WORD color) {
if (hConsole) {
SetConsoleTextAttribute(hConsole, color); }
}
void ConsoleUtils::ResetColor() {
if (hConsole) {
SetConsoleTextAttribute(hConsole, originalAttributes); }
}
void ConsoleUtils::PrintBanner() {
if (!isInitialized) Init(); SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf("============================================\n"); printf("||           M I K A B O O M            ||\n"); printf("||       Resource Monitor System        ||\n"); printf("============================================\n"); ResetColor(); printf("\n"); SetColor(FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY); std::string art = Version::GetRandomAsciiArt(); printf("%s\n\n", art.c_str()); ResetColor(); SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf("Resource Monitor - Miku Edition\n"); printf("=======================================\n"); ResetColor(); printf("\n"); }
void ConsoleUtils::PrintSystemInfo() {
if (!isInitialized) Init(); SYSTEM_INFO sysInfo; ::GetSystemInfo(&sysInfo); MEMORYSTATUSEX memInfo; memInfo.dwLength = sizeof(MEMORYSTATUSEX); GlobalMemoryStatusEx(&memInfo); SetColor(FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(">> 操作系统: %s\n", SystemInfo::GetOSName()); printf("\n"); printf(">> 版本: %s\n", Version::GetVersion()); printf(">> 构建时间: %s\n", Version::GetBuildDate()); printf(">> 升级时间: %s\n", Version::GetExpireDate()); printf(">> 作者: %s\n", Version::GetAuthor()); } else {
printf("OS: %s\n", SystemInfo::GetOSName()); printf("\n"); printf("Version: %s\n", Version::GetVersion()); printf("Build Date: %s\n", Version::GetBuildDate()); printf("Expire Date: %s\n", Version::GetExpireDate()); printf("Author: %s\n", Version::GetAuthor()); }
ResetColor(); printf("\n");
if (!Version::IsValid()) {
SetColor(FOREGROUND_RED | FOREGROUND_INTENSITY);
if (useUTF8) {
printf("=======================================\n"); printf("!! 版本需更新\n"); printf("!! 不支持的版本，请更新应用程序\n"); printf("!! 当前仅支持监控功能，计算功能文件缺失\n"); printf("=======================================\n"); } else {
printf("=======================================\n"); printf("WARNING: Version needs update\n"); printf("Please update the application\n"); printf("Only monitoring mode available\n"); printf("=======================================\n"); }
ResetColor(); } else {
int daysLeft = Version::GetDaysUntilExpire();
if (daysLeft <= 30) {
SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
if (useUTF8) {
printf("=======================================\n"); printf("!! 版本将在 %d 天后更新\n", daysLeft); printf("=======================================\n"); } else {
printf("=======================================\n"); printf("WARNING: Version will expire in %d days\n", daysLeft); printf("=======================================\n"); }
ResetColor(); } else if (daysLeft <= 90) {
SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(">> 版本更新期剩余: %d 天\n", daysLeft); } else {
printf("Version valid for %d days\n", daysLeft); }
ResetColor(); } else {
SetColor(FOREGROUND_GREEN | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(">> 版本更新 (剩余 %d 天)\n", daysLeft); } else {
printf("Version valid (%d days remaining)\n", daysLeft); }
ResetColor(); }
}
printf("\n"); }
void ConsoleUtils::ShowWelcome() {
Init(); PrintBanner(); PrintSystemInfo(); }
void ConsoleUtils::ShowVersion() {
Init(); PrintBanner(); PrintSystemInfo(); }
void ConsoleUtils::PrintHelpContent() {
if (!isInitialized) Init(); SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(">> 用法:\n"); } else {
printf("USAGE:\n"); }
ResetColor(); printf("  MikaBooM.exe [options] <value>\n\n"); SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(">> 选项:\n"); } else {
printf("OPTIONS:\n"); }
ResetColor();
if (useUTF8) {
printf("  -cpu <value>        设置CPU占用率阈值 (0-100)\n"); printf("                      示例: -cpu 80\n\n"); printf("  -mem <value>        设置内存占用率阈值 (0-100)\n"); printf("                      示例: -mem 70\n\n"); printf("  -window <value>     设置窗口显示模式\n"); printf("                      true/1/yes/on  - 显示窗口（前台运行）\n"); printf("                      false/0/no/off - 隐藏窗口（后台运行）\n"); printf("                      示例: -window false\n\n"); printf("  -auto               启用开机自启动\n\n"); printf("  -noauto             禁用开机自启动\n\n"); printf("  -c <file>           指定配置文件路径\n"); printf("                      支持绝对路径和相对路径\n"); printf("                      示例: -c C:\\config.ini\n\n"); printf("  -v                  显示版本信息\n\n"); printf("  -h                  显示此帮助信息\n\n"); SetColor(FOREGROUND_GREEN | FOREGROUND_INTENSITY); printf(">> 示例:\n"); ResetColor(); printf("  # 首次运行（自动创建配置文件）\n"); printf("  MikaBooM.exe\n\n"); printf("  # 使用默认配置文件，设置CPU阈值80%%\n"); printf("  MikaBooM.exe -cpu 80\n\n"); printf("  # 后台运行，不显示窗口\n"); printf("  MikaBooM.exe -window false\n\n"); printf("  # 启用开机自启动\n"); printf("  MikaBooM.exe -auto\n\n"); printf("  # 禁用开机自启动\n"); printf("  MikaBooM.exe -noauto\n\n"); printf("  # 使用自定义配置文件\n"); printf("  MikaBooM.exe -c C:\\custom-config.ini\n\n"); printf("  # 查看版本信息\n"); printf("  MikaBooM.exe -v\n\n"); SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf(">> 配置文件:\n"); ResetColor(); printf("  默认位置: 可执行文件同级目录下的 config.ini\n\n"); printf("  支持的配置项:\n"); printf("    - cpu_threshold      CPU阈值 (0-100)\n"); printf("    - memory_threshold   内存阈值 (0-100)\n"); printf("    - show_window        是否显示窗口 (true/false)\n"); printf("    - auto_start         是否自启动 (true/false)\n"); printf("    - update_interval    更新间隔（秒）\n"); printf("    - notification       通知设置\n\n"); SetColor(FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf(">> 作者: Makoto\n"); SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf(">> 项目: MikaBooM - Resource Monitor Miku Edition\n"); } else {
printf("  -cpu <value>        Set CPU threshold (0-100)\n"); printf("                      Example: -cpu 80\n\n"); printf("  -mem <value>        Set Memory threshold (0-100)\n"); printf("                      Example: -mem 70\n\n"); printf("  -window <value>     Set window display mode\n"); printf("                      true/1/yes/on  - Show window\n"); printf("                      false/0/no/off - Hide window\n"); printf("                      Example: -window false\n\n"); printf("  -auto               Enable auto-start\n\n"); printf("  -noauto             Disable auto-start\n\n"); printf("  -c <file>           Specify config file path\n"); printf("                      Example: -c C:\\config.ini\n\n"); printf("  -v                  Show version\n\n"); printf("  -h                  Show this help\n\n"); SetColor(FOREGROUND_GREEN | FOREGROUND_INTENSITY); printf("EXAMPLES:\n"); ResetColor(); printf("  MikaBooM.exe\n"); printf("  MikaBooM.exe -cpu 80\n"); printf("  MikaBooM.exe -window false\n"); printf("  MikaBooM.exe -auto\n\n"); SetColor(FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf("Author: Makoto\n"); SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf("Project: MikaBooM - Resource Monitor Miku Edition\n"); }
ResetColor(); printf("\n"); }
void ConsoleUtils::ShowHelp() {
Init(); PrintBanner(); PrintHelpContent(); }
void ConsoleUtils::PrintInfo(const char* format, ...) {
SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY); printf("[INFO] "); ResetColor(); va_list args; va_start(args, format); vprintf(format, args); va_end(args); printf("\n"); }
void ConsoleUtils::PrintSuccess(const char* format, ...) {
SetColor(FOREGROUND_GREEN | FOREGROUND_INTENSITY); printf("[OK] "); ResetColor(); va_list args; va_start(args, format); vprintf(format, args); va_end(args); printf("\n"); }
void ConsoleUtils::PrintWarning(const char* format, ...) {
SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY); printf("[WARN] "); ResetColor(); va_list args; va_start(args, format); vprintf(format, args); va_end(args); printf("\n"); }
void ConsoleUtils::PrintError(const char* format, ...) {
SetColor(FOREGROUND_RED | FOREGROUND_INTENSITY); printf("[ERROR] "); ResetColor(); va_list args; va_start(args, format); vprintf(format, args); va_end(args); printf("\n"); }
void ConsoleUtils::PrintStatus(double cpu, double mem, bool cpuWork, bool memWork, int cpuIntensity, size_t memAllocMB) {
time_t now = time(0); struct tm timeinfo; struct tm* tmp = localtime(&now);
if (tmp) {
timeinfo = *tmp; } else {
memset(&timeinfo, 0, sizeof(timeinfo)); }
printf("[%02d:%02d:%02d] ", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
if (cpu > 80) {
SetColor(FOREGROUND_RED | FOREGROUND_INTENSITY); } else if (cpu > 60) {
SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY); } else {
SetColor(FOREGROUND_GREEN | FOREGROUND_INTENSITY); }
printf("CPU: %5.1f%% ", cpu); ResetColor();
if (mem > 80) {
SetColor(FOREGROUND_RED | FOREGROUND_INTENSITY); } else if (mem > 60) {
SetColor(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY); } else {
SetColor(FOREGROUND_GREEN | FOREGROUND_INTENSITY); }
printf("MEM: %5.1f%%", mem); ResetColor();
if (cpuWork) {
SetColor(FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(" [CPU计算: 运行中 (强度:%d%%)]", cpuIntensity); } else {
printf(" [CPU-W: ON, I:%d%%]", cpuIntensity); }
} else {
SetColor(FOREGROUND_INTENSITY);
if (useUTF8) {
printf(" [CPU计算: 已停止]"); } else {
printf(" [CPU-W: OFF]"); }
}
ResetColor();
if (memWork) {
SetColor(FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
if (useUTF8) {
printf(" [内存计算: 运行中 (已分配:%luMB)]", (unsigned long)memAllocMB); } else {
printf(" [MEM-W: ON, A:%luMB]", (unsigned long)memAllocMB); }
} else {
SetColor(FOREGROUND_INTENSITY);
if (useUTF8) {
printf(" [内存计算: 已停止]"); } else {
printf(" [MEM-W: OFF]"); }
}
ResetColor(); printf("\n"); }
```

### 17. src\utils\console_utils.h

```c
#pragma once
#include <windows.h>
#include <string>
class ConsoleUtils {
public:
static void Init(); static void ShowWelcome(); static void ShowVersion(); static void ShowHelp(); static void PrintInfo(const char* format, ...); static void PrintSuccess(const char* format, ...); static void PrintWarning(const char* format, ...); static void PrintError(const char* format, ...); static void PrintStatus(double cpu, double mem, bool cpuWork, bool memWork, int cpuIntensity, size_t memAllocMB); static bool IsWindows7OrLater();
private:
static void SetColor(WORD color); static void ResetColor(); static void PrintBanner(); static void PrintSystemInfo(); static void PrintVersionInfo(); static void PrintHelpContent(); static bool useUTF8; static bool initialized; };
```

### 18. src\utils\system_info.h

```c
#pragma once
#include <windows.h>
#include <stdio.h>
#include <string.h>
typedef LONG (WINAPI* RtlGetVersionPtr)(PRTL_OSVERSIONINFOEXW);
class SystemInfo {
public:
static bool IsWindows7OrLater() {
DWORD major = 0, minor = 0; GetRealWindowsVersion(major, minor);
if (major > 6) {
return true; }
if (major == 6 && minor >= 1) {
return true; }
return false; }
static const char* GetOSName() {
static char osName[256] = {0};
if (osName[0] != '\0') return osName; DWORD major = 0, minor = 0, build = 0; GetRealWindowsVersion(major, minor, &build);
if (major == 10) {
if (build >= 22000) {
strcpy(osName, "Windows 11"); } else {
strcpy(osName, "Windows 10"); }
} else if (major == 6) {
if (minor == 3) {
strcpy(osName, "Windows 8.1"); } else if (minor == 2) {
strcpy(osName, "Windows 8"); } else if (minor == 1) {
strcpy(osName, "Windows 7"); } else if (minor == 0) {
strcpy(osName, "Windows Vista"); }
} else if (major == 5) {
if (minor == 2) {
strcpy(osName, "Windows Server 2003"); } else if (minor == 1) {
strcpy(osName, "Windows XP"); } else if (minor == 0) {
strcpy(osName, "Windows 2000"); }
} else {
sprintf(osName, "Windows (Version %lu.%lu)", major, minor); }
return osName; }
static void GetRealWindowsVersion(DWORD& major, DWORD& minor, DWORD* build = NULL) {
major = 0; minor = 0;
if (build) *build = 0; HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
if (hNtdll) {
RtlGetVersionPtr pRtlGetVersion = (RtlGetVersionPtr)GetProcAddress(hNtdll, "RtlGetVersion");
if (pRtlGetVersion) {
OSVERSIONINFOEXW osvi; ZeroMemory(&osvi, sizeof(osvi)); osvi.dwOSVersionInfoSize = sizeof(osvi);
if (pRtlGetVersion((PRTL_OSVERSIONINFOEXW)&osvi) == 0) {
major = osvi.dwMajorVersion; minor = osvi.dwMinorVersion;
if (build) *build = osvi.dwBuildNumber;
return; }
}
}
OSVERSIONINFOEXA osvi; ZeroMemory(&osvi, sizeof(osvi)); osvi.dwOSVersionInfoSize = sizeof(osvi);
if (GetVersionExA((LPOSVERSIONINFOA)&osvi)) {
major = osvi.dwMajorVersion; minor = osvi.dwMinorVersion;
if (build) *build = osvi.dwBuildNumber;
return; }
OSVERSIONINFOA basicOsvi; ZeroMemory(&basicOsvi, sizeof(basicOsvi)); basicOsvi.dwOSVersionInfoSize = sizeof(basicOsvi);
if (GetVersionExA(&basicOsvi)) {
major = basicOsvi.dwMajorVersion; minor = basicOsvi.dwMinorVersion;
if (build) *build = basicOsvi.dwBuildNumber; }
}
};
```

### 19. src\utils\version.cpp

```cpp
#include "version.h"
#include <ctime>
#include <cstring>
#include <cstdio>
#include <cstdlib>
const char* Version::asciiArtsUTF8[] = {
"⣇⣿⠘⣿⣿⣿⡿⡿⣟⣟⢟⢟⢝⠵⡝⣿⡿⢂⣼⣿⣷⣌⠩⡫⡻⣝⠹⢿⣿⣷\n"
"⡆⣿⣆⠱⣝⡵⣝⢅⠙⣿⢕⢕⢕⢕⢝⣥⢒⠅⣿⣿⣿⡿⣳⣌⠪⡪⣡⢑⢝⣇\n"
"⡆⣿⣿⣦⠹⣳⣳⣕⢅⠈⢗⢕⢕⢕⢕⢕⢈⢆⠟⠋⠉⠁⠉⠉⠁⠈⠼⢐⢕⢽\n"
"⡗⢰⣶⣶⣦⣝⢝⢕⢕⠅⡆⢕⢕⢕⢕⢕⣴⠏⣠⡶⠛⡉⡉⡛⢶⣦⡀⠐⣕⢕\n"
"⡝⡄⢻⢟⣿⣿⣷⣕⣕⣅⣿⣔⣕⣵⣵⣿⣿⢠⣿⢠⣮⡈⣌⠨⠅⠹⣷⡀⢱⢕\n"
"⡝⡵⠟⠈⢀⣀⣀⡀⠉⢿⣿⣿⣿⣿⣿⣿⣿⣼⣿⢈⡋⠴⢿⡟⣡⡇⣿⡇⡀⢕\n"
"⡝⠁⣠⣾⠟⡉⡉⡉⠻⣦⣻⣿⣿⣿⣿⣿⣿⣿⣿⣧⠸⣿⣦⣥⣿⡇⡿⣰⢗⢄\n"
"⠁⢰⣿⡏⣴⣌⠈⣌⠡⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣬⣉⣉⣁⣄⢖⢕⢕⢕\n"
"⡀⢻⣿⡇⢙⠁⠴⢿⡟⣡⡆⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣵⣵⣿\n"
"⡻⣄⣻⣿⣌⠘⢿⣷⣥⣿⠇⣿⣿⣿⣿⣿⣿⠛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n"
"⣷⢄⠻⣿⣟⠿⠦⠍⠉⣡⣾⣿⣿⣿⣿⣿⣿⢸⣿⣦⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟\n"
"⡕⡑⣑⣈⣻⢗⢟⢞⢝⣻⣿⣿⣿⣿⣿⣿⣿⠸⣿⠿⠃⣿⣿⣿⣿⣿⣿⡿⠁⣠\n"
"⡝⡵⡈⢟⢕⢕⢕⢕⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣿⣿⣿⣿⣿⠿⠋⣀⣈⠙\n"
"⡝⡵⡕⡀⠑⠳⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢉⡠⡲⡫⡪⡪⡣\n", "⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣬⡛⣿⣿⣿⣯⢻ \n"
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢻⣿⣿⢟⣻⣿⣿⣿⣿⣿⣿⣮⡻⣿⣿⣧ \n"
"⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣆⠻⡫⣢⠿⣿⣿⣿⣿⣿⣿⣿⣷⣜⢻⣿ \n"
"⣿⣿⡏⣿⣿⣨⣝⠿⣿⣿⣿⣿⣿⢕⠸⣛⣩⣥⣄⣩⢝⣛⡿⠿⣿⣿⣆⢝ \n"
"⣿⣿⢡⣸⣿⣏⣿⣿⣶⣯⣙⠫⢺⣿⣷⡈⣿⣿⣿⣿⡿⠿⢿⣟⣒⣋⣙⠊ \n"
"⣿⡏⡿⣛⣍⢿⣮⣿⣿⣿⣿⣿⣿⣿⣶⣶⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿ \n"
"⣿⢱⣾⣿⣿⣿⣝⡮⡻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⣋⣻⣿⣿⣿⣿ \n"
"⢿⢸⣿⣿⣿⣿⣿⣿⣷⣽⣿⣿⣿⣿⣿⣿⣿⡕⣡⣴⣶⣿⣿⣿⡟⣿⣿⣿ \n"
"⣦⡸⣿⣿⣿⣿⣿⣿⡛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⣿⣿⣿ \n"
"⢛⠷⡹⣿⠋⣉⣠⣤⣶⣶⣿⣿⣿⣿⣿⣿⡿⠿⢿⣿⣿⣿⣿⣿⣷⢹⣿⣿ \n"
"⣷⡝⣿⡞⣿⣿⣿⣿⣿⣿⣿⣿⡟⠋⠁⣠⣤⣤⣦⣽⣿⣿⣿⡿⠋⠘⣿⣿ \n"
"⣿⣿⡹⣿⡼⣿⣿⣿⣿⣿⣿⣿⣧⡰⣿⣿⣿⣿⣿⣹⡿⠟⠉⡀⠄⠄⢿⣿ \n"
"⣿⣿⣿⣽⣿⣼⣛⠿⠿⣿⣿⣿⣿⣿⣯⣿⠿⢟⣻⡽⢚⣤⡞⠄⠄⠄⢸⣿\n", "⣿⢸⣿⣿⣿⣿⣿⢹⣿⣿⣿⣿⣿⢿⣿⡇⡇⣿⣿⡇⢹⣿⣿⣿⣿⣿⣿⠄⢸⣿\n"
"⡟⢸⣿⣿⣭⣭⡭⣼⣶⣿⣿⣿⣿⢸⣧⣇⠇⢸⣿⣿⠈⣿⣿⣿⣿⣿⣿⡆⠘⣿\n"
"⡇⢸⣿⣿⣿⣿⡇⣻⡿⣿⣿⡟⣿⢸⣿⣿⠇⡆⣝⠿⡌⣸⣿⣿⣿⣿⣿⡇⠄⣿\n"
"⢣⢾⣾⣷⣾⣽⣻⣿⣇⣿⣿⣧⣿⢸⣿⣿⡆⢸⣹⣿⣆⢥⢛⡿⣿⣿⣿⡇⠄⣿\n"
"⣛⡓⣉⠉⠙⠻⢿⣿⣿⣟⣻⠿⣹⡏⣿⣿⣧⢸⣧⣿⣿⣨⡟⣿⣿⣿⣿⡇⠄⣿\n"
"⠸⣷⣹⣿⠄⠄⠄⠄⠘⢿⣿⣿⣯⣳⣿⣭⣽⢼⣿⣜⣿⣇⣷⡹⣿⣿⣿⠁⢰⣿\n"
"⠄⢻⣷⣿⡄⢈⠿⠇⢸⣿⣿⣿⣿⣿⣿⣟⠛⠲⢯⣿⣒⡾⣼⣷⡹⣿⣿⠄⣼⣿\n"
"⡄⢸⣿⣿⣷⣬⣽⣯⣾⣿⣿⣿⣿⣿⣿⣿⣿⡀⠄⢀⠉⠙⠛⠛⠳⠽⠿⢠⣿⣿\n"
"⡇⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢄⣹⡿⠃⠄⠄⣰⠎⡈⣾⣿⣿\n"
"⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣭⣽⣖⣄⣴⣯⣾⢷⣿⣿⣿\n"
"⣧⠸⣿⣿⣿⣿⣿⣿⠯⠊⠙⢻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣾⣿⣿⣿\n"
"⣿⣦⠹⣿⣿⣿⣿⣿⠄⢀⣴⢾⣼⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣾⣿⣿⣿⣿\n"
"⣿⣿⣇⢽⣿⣿⣿⡏⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⡿⣿⣛⣻⠿⣟⣼⣿⣿⣿⣿⢃\n"
"⣿⣿⣿⡎⣷⣽⠻⣇⣿⣿⣿⡿⣟⣵⣿⣟⣽⣾⣿⣿⣿⣿⢯⣾⣿⣿⣿⠟⠱⡟\n"
"⣿⣿⣿⣿⢹⣿⣿⢮⣚⡛⠒⠛⢛⣋⣶⣿⣿⣿⣿⣿⣟⣱⠿⣿⣿⠟⣡⣺⢿\n", "⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄\n"
"⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄\n"
"⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄\n"
"⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄\n"
"⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰\n"
"⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤\n"
"⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗\n"
"⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄\n"
"⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄\n"
"⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄\n"
"⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄\n"
"⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄\n"
"⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴\n"
"⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿\n", "⠄⠄⠄⣰⣿⠄⠄⠄⠄⠄⢠⠄⠄⢀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄\n"
"⠄⠄⢰⣿⠿⠄⡀⠄⠄⠄⠘⣷⡀⠄⠢⣄⠄⠄⠄⠄⠄⠄⠄⣠⠖⠁⠄⠄⠄⠄\n"
"⠄⣤⢸⣿⣿⣆⠣⠄⠄⠄⠄⠸⣿⣦⡀⠙⢶⣦⣄⡀⠄⡠⠞⠁⢀⡴⠄⠄⠄⠄\n"
"⢰⣿⣎⣿⣿⣿⣦⣀⠄⠄⠄⠄⠹⣿⣿⣦⢄⡙⠻⠿⠷⠶⠤⢐⣋⣀⠄⠄⠄⠄\n"
"⢸⣿⠛⠛⠻⠿⢿⣿⣧⢤⣤⣄⣠⡘⣿⣿⣿⡟⠿⠛⠂⠈⠉⠛⢿⣿⠄⠄⠄⠄\n"
"⠄⡇⢰⣿⣇⡀⠄⠄⣝⣿⣿⣿⣿⣿⣿⣿⣿⣶⣿⡄⠄⠈⠄⣷⢠⡆⠄⠄⠄⠄\n"
"⢹⣿⣼⣿⣯⢁⣤⣄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⣴⠶⣲⣵⠟⠄⠄⠄⠄⠸\n"
"⠄⢿⣿⣿⣿⣷⣮⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣟⣡⡴⠄⠄⠄⠄⠁\n"
"⠄⠰⣭⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⡀⠄⠄⠄⠄\n"
"⠄⠄⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⣶⡞⠄⠄⠄⠄⠄\n"
"⠄⠄⠐⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⠄⠄⠄⠄\n"
"⠄⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⣯⣿⣯⣿⣾⣿⣿⣿⣿⣿⡿⠋⠄⠄⠄⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⠄⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣵⠄⠄⠄⠄⠄⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⠄⠄⢀⣿⣯⣟⣿⣿⣿⡿⣟⣯⣷⣿⣿⡏⣤⠄⠄⠄⠄⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⠄⠄⣞⢸⣿⣿⣿⣾⣷⣿⣿⣿⣿⣿⣿⣇⣿⡆⠄⠄⠄⠄⠄⠄⠄\n", "⠄⠄⢿⣇⠄⠄⠘⣆⢀⣼⣿⣿⣿⣿⢿⡿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣟⢧⡲⣿⢷⢦⡀\n"
"⠄⠄⠈⣿⠄⠄⠄⢙⢞⢿⣿⢹⢿⣦⢏⣱⢿⠘⣿⣝⠹⢿⣿⡽⣿⣿⣏⣆⢿⣿⡞⠁\n"
"⠄⠄⠄⢻⡀⠄⠄⠈⣾⡸⡏⢸⡾⣴⣿⣿⣶⣼⣎⢵⢀⡛⣿⣷⡙⡻⢻⡴⠨⠨⠖⠃\n"
"⠄⠄⠄⠈⣧⢀⡴⠊⢹⠁⡇⠈⢣⣿⣿⣿⣿⣦⣿⣷⣜⡳⣝⢧⢃⢣⣼⢁⠘⠆⠄⠄\n"
"⠄⠄⠄⠄⢹⡇⠄⣠⠔⠚⣅⠄⢰⣶⣦⣭⣿⣿⣿⡿⠟⠿⣷⡧⠄⣘⣟⣸⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⢷⠎⠄⠄⠄⣼⣦⠻⣿⣿⡟⠛⠻⢿⣿⣿⣿⡾⢱⣿⡏⠸⡏⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⠸⡄⠄⡄⠄⣿⢧⢗⠌⠻⣇⠿⠿⣸⣿⣿⡟⡐⣿⠟⢰⣇⠇⠄⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⣠⡆⠄⠃⢠⠏⣤⢀⢢⡰⣭⣛⡉⠩⠭⡅⣾⢳⡴⡀⢸⣿⡆⠄⠄⠄⠄\n"
"⠄⠄⠄⢀⣶⡟⣽⠼⢀⡕⢀⠘⠸⢮⡳⡻⡍⡷⡆⠤⠤⠭⢸⢳⣷⢸⡟⣷⠄⠄⠄⠄\n"
"⠄⠄⣴⣿⢫⢞⣵⢏⡞⠄⢸⠄⣛⣗⠩⠄⣰⣚⠒⠂⣀⡀⢸⢸⣿⣧⠇⡼⣧⠄⠄⠄\n"
"⢠⣾⢟⡴⢫⡾⣱⢟⠄⠄⢸⠄⢈⡓⡮⡦⡬⠽⡠⠄⠔⠄⢸⠈⣿⣿⡄⣷⢹⣆⠄⠄\n"
"⡿⢁⠞⢀⣿⢣⠇⣿⠄⠄⠸⢀⢳⢣⣗⣿⡇⡔⠄⠔⠄⠄⢠⠄⠹⣿⣷⡝⣧⢻⣆\n", "⣿⡇⣿⣿⣿⠛⠁⣴⣿⡿⠿⠧⠹⠿⠘⣿⣿⣿⡇⢸⡻⣿⣿⣿⣿⣿⣿⣿\n"
"⢹⡇⣿⣿⣿⠄⣞⣯⣷⣾⣿⣿⣧⡹⡆⡀⠉⢹⡌⠐⢿⣿⣿⣿⡞⣿⣿⣿\n"
"⣾⡇⣿⣿⡇⣾⣿⣿⣿⣿⣿⣿⣿⣿⣄⢻⣦⡀⠁⢸⡌⠻⣿⣿⣿⡽⣿⣿\n"
"⡇⣿⠹⣿⡇⡟⠛⣉⠁⠉⠉⠻⡿⣿⣿⣿⣿⣿⣦⣄⡉⠂⠈⠙⢿⣿⣝⣿\n"
"⠤⢿⡄⠹⣧⣷⣸⡇⠄⠄⠲⢰⣌⣾⣿⣿⣿⣿⣿⣿⣶⣤⣤⡀⠄⠈⠻⢮\n"
"⠄⢸⣧⠄⢘⢻⣿⡇⢀⣀⠄⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠄⢀\n"
"⠄⠈⣿⡆⢸⣿⣿⣿⣬⣭⣴⣿⣿⣿⣿⣿⣿⣿⣯⠝⠛⠛⠙⢿⡿⠃⠄⢸\n"
"⠄⠄⢿⣿⡀⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⡾⠁⢠⡇⢀\n"
"⠄⠄⢸⣿⡇⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣏⣫⣻⡟⢀⠄⣿⣷⣾\n"
"⠄⠄⢸⣿⡇⠄⠈⠙⠿⣿⣿⣿⣮⣿⣿⣿⣿⣿⣿⣿⣿⡿⢠⠊⢀⡇⣿⣿\n"
"⠒⠤⠄⣿⡇⢀⡲⠄⠄⠈⠙⠻⢿⣿⣿⠿⠿⠟⠛⠋⠁⣰⠇⠄⢸⣿⣿⣿\n"
"⠄⠄⠄⣿⡇⢬⡻⡇⡄⠄⠄⠄⡰⢖⠔⠉⠄⠄⠄⠄⣼⠏⠄⠄⢸⣿⣿⣿\n"
"⠄⠄⠄⣿⡇⠄⠙⢌⢷⣆⡀⡾⡣⠃⠄⠄⠄⠄⠄⣼⡟⠄⠄⠄⠄⢿⣿⣿\n", "⣿⣿⣷⡁⢆⠈⠕⢕⢂⢕⢂⢕⢂⢔⢂⢕⢄⠂⣂⠂⠆⢂⢕⢂⢕⢂⢕⢂⢕⢂\n"
"⣿⣿⣿⡷⠊⡢⡹⣦⡑⢂⢕⢂⢕⢂⢕⢂⠕⠔⠌⠝⠛⠶⠶⢶⣦⣄⢂⢕⢂⢕\n"
"⣿⣿⠏⣠⣾⣦⡐⢌⢿⣷⣦⣅⡑⠕⠡⠐⢿⠿⣛⠟⠛⠛⠛⠛⠡⢷⡈⢂⢕⢂\n"
"⠟⣡⣾⣿⣿⣿⣿⣦⣑⠝⢿⣿⣿⣿⣿⣿⡵⢁⣤⣶⣶⣿⢿⢿⢿⡟⢻⣤⢑⢂\n"
"⣾⣿⣿⡿⢟⣛⣻⣿⣿⣿⣦⣬⣙⣻⣿⣿⣷⣿⣿⢟⢝⢕⢕⢕⢕⢽⣿⣿⣷⣔\n"
"⣿⣿⠵⠚⠉⢀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣗⢕⢕⢕⢕⢕⢕⣽⣿⣿⣿⣿\n"
"⢷⣂⣠⣴⣾⡿⡿⡻⡻⣿⣿⣴⣿⣿⣿⣿⣿⣿⣷⣵⣵⣵⣷⣿⣿⣿⣿⣿⣿⡿\n"
"⢌⠻⣿⡿⡫⡪⡪⡪⡪⣺⣿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃\n"
"⠣⡁⠹⡪⡪⡪⡪⣪⣾⣿⣿⣿⣿⠋⠐⢉⢍⢄⢌⠻⣿⣿⣿⣿⣿⣿⣿⣿⠏⠈\n"
"⡣⡘⢄⠙⣾⣾⣾⣿⣿⣿⣿⣿⣿⡀⢐⢕⢕⢕⢕⢕⡘⣿⣿⣿⣿⣿⣿⠏⠠⠈\n"
"⠌⢊⢂⢣⠹⣿⣿⣿⣿⣿⣿⣿⣿⣧⢐⢕⢕⢕⢕⢕⢅⣿⣿⣿⣿⡿⢋⢜⠠⠈\n"
"⠄⠁⠕⢝⡢⠈⠻⣿⣿⣿⣿⣿⣿⣿⣷⣕⣑⣑⣑⣵⣿⣿⣿⡿⢋⢔⢕⣿⠠⠈\n"
"⠨⡂⡀⢑⢕⡅⠂⠄⠉⠛⠻⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢋⢔⢕⢕⣿⣿⠠⠈\n"
"⠄⠪⣂⠁⢕⠆⠄⠂⠄⠁⡀⠂⡀⠄⢈⠉⢍⢛⢛⢛⢋⢔⢕⢕⢕⣽⣿⣿⠠⠈\n", "⡿⠉⠄⠄⠄⠄⠈⠙⠿⠟⠛⠉⠉⠉⠄⠄⠄⠈⠉⠉⠉⠛⠛⠻⢿⣿⣿⣿⣿⣿\n"
"⠁⠄⠄⠄⢀⡴⣋⣵⣮⠇⡀⠄⠄⠄⠄⠄⠄⢀⠄⠄⠄⡀⠄⠄⠄⠈⠛⠿⠋⠉\n"
"⠄⠄⠄⢠⣯⣾⣿⡿⣳⡟⣰⣿⣠⣂⡀⢀⠄⢸⡄⠄⢀⣈⢆⣱⣤⡀⢄⠄⠄⠄\n"
"⠄⠄⠄⣼⣿⣿⡟⣹⡿⣸⣿⢳⣿⣿⣿⣿⣴⣾⢻⣆⣿⣿⣯⢿⣿⣿⣷⣧⣀⣤\n"
"⠄⠄⣼⡟⣿⠏⢀⣿⣇⣿⣏⣿⣿⣿⣿⣿⣿⣿⢸⡇⣿⣿⣿⣟⣿⣿⣿⣿⣏⠋\n"
"⡆⣸⡟⣼⣯⠏⣾⣿⢸⣿⢸⣿⣿⣿⣿⣿⣿⡟⠸⠁⢹⡿⣿⣿⢻⣿⣿⣿⣿⠄\n"
"⡇⡟⣸⢟⣫⡅⣶⢆⡶⡆⣿⣿⣿⣿⣿⢿⣛⠃⠰⠆⠈⠁⠈⠙⠈⠻⣿⢹⡏⠄\n"
"⣧⣱⡷⣱⠿⠟⠛⠼⣇⠇⣿⣿⣿⣿⣿⣿⠃⣰⣿⣿⡆⠄⠄⠄⠄⠄⠉⠈⠄⠄\n"
"⡏⡟⢑⠃⡠⠂⠄⠄⠈⣾⢻⣿⣿⡿⡹⡳⠋⠉⠁⠉⠙⠄⢀⠄⠄⠄⠄⠄⠂⠄\n"
"⡇⠁⢈⢰⡇⠄⠄⡙⠂⣿⣿⣿⣿⣱⣿⡗⠄⠄⠄⢀⡀⠄⠈⢰⠄⠄⠄⠐⠄⠄\n"
"⠄⠄⠘⣿⣧⠴⣄⣡⢄⣿⣿⣿⣷⣿⣿⡇⢀⠄⠤⠈⠁⣠⣠⣸⢠⠄⠄⠄⠄⠄\n"
"⢀⠄⠄⣿⣿⣷⣬⣵⣿⣿⣿⣿⣿⣿⣿⣷⣟⢷⡶⢗⡰⣿⣿⠇⠘⠄⠄⠄⠄⠄\n"
"⣿⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣾⣿⣿⡟⢀⠃⠄⢸⡄⠁⣸\n"
"⣿⠄⠄⠘⢿⣿⣿⣿⣿⣿⣿⢛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⢄⡆⠄⢀⣪⡆⠄⣿\n"
"⡟⠄⠄⠄⠄⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⣟⣻⣩⣾⣃⣴⣿⣿⡇⠸⢾\n", "⡆⣐⢕⢕⢕⢕⢕⢕⢕⢕⠅⢗⢕⢕⢕⢕⢕⢕⢕⠕⠕⢕⢕⢕⢕⢕⢕⢕⢕⢕\n"
"⢐⢕⢕⢕⢕⢕⣕⢕⢕⠕⠁⢕⢕⢕⢕⢕⢕⢕⢕⠅⡄⢕⢕⢕⢕⢕⢕⢕⢕⢕\n"
"⢕⢕⢕⢕⢕⠅⢗⢕⠕⣠⠄⣗⢕⢕⠕⢕⢕⢕⠕⢠⣿⠐⢕⢕⢕⠑⢕⢕⠵⢕\n"
"⢕⢕⢕⢕⠁⢜⠕⢁⣴⣿⡇⢓⢕⢵⢐⢕⢕⠕⢁⣾⢿⣧⠑⢕⢕⠄⢑⢕⠅⢕\n"
"⢕⢕⠵⢁⠔⢁⣤⣤⣶⣶⣶⡐⣕⢽⠐⢕⠕⣡⣾⣶⣶⣶⣤⡁⢓⢕⠄⢑⢅⢑\n"
"⠍⣧⠄⣶⣾⣿⣿⣿⣿⣿⣿⣷⣔⢕⢄⢡⣾⣿⣿⣿⣿⣿⣿⣿⣦⡑⢕⢤⠱⢐\n"
"⢠⢕⠅⣾⣿⠋⢿⣿⣿⣿⠉⣿⣿⣷⣦⣶⣽⣿⣿⠈⣿⣿⣿⣿⠏⢹⣷⣷⡅⢐\n"
"⣔⢕⢥⢻⣿⡀⠈⠛⠛⠁⢠⣿⣿⣿⣿⣿⣿⣿⣿⡀⠈⠛⠛⠁⠄⣼⣿⣿⡇⢔\n"
"⢕⢕⢽⢸⢟⢟⢖⢖⢤⣶⡟⢻⣿⡿⠻⣿⣿⡟⢀⣿⣦⢤⢤⢔⢞⢿⢿⣿⠁⢕\n"
"⢕⢕⠅⣐⢕⢕⢕⢕⢕⣿⣿⡄⠛⢀⣦⠈⠛⢁⣼⣿⢗⢕⢕⢕⢕⢕⢕⡏⣘⢕\n"
"⢕⢕⠅⢓⣕⣕⣕⣕⣵⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣷⣕⢕⢕⢕⢕⡵⢀⢕⢕\n"
"⢑⢕⠃⡈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢃⢕⢕⢕\n"
"⣆⢕⠄⢱⣄⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢁⢕⢕⠕⢁\n"
"⣿⣦⡀⣿⣿⣷⣶⣬⣍⣛⣛⣛⡛⠿⠿⠿⠛⠛⢛⣛⣉⣭⣤⣂⢜⠕⢑⣡⣴⣿\n", "⣿⣿⣿⣿⣿⣿⠟⠋⠁⣀⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿\n"
"⣿⣿⣿⣿⠋⠁⠀⠀⠺⠿⢿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⣿\n"
"⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⣤⣤⠀⠀⠀⠀⠀⣤⣦⣄⠀⠀\n"
"⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣿⠏⣿⣿⣿⣿⣿⣁⠀⠀⠀⠛⠙⠛⠋⠀⠀\n"
"⡿⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⣰⣿⣿⣿⣿⡄⠘⣿⣿⣿⣿⣷⠄⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⡇⠀⠀⠀⠀⠀⠀⠀⠸⠇⣼⣿⣿⣿⣿⣿⣷⣄⠘⢿⣿⣿⣿⣅⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠁⠀⠀⠀⣴⣿⠀⣐⣣⣸⣿⣿⣿⣿⣿⠟⠛⠛⠀⠌⠻⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⣶⣮⣽⣰⣿⡿⢿⣿⣿⣿⣿⣿⡀⢿⣤⠄⢠⣄⢹⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⣿⣿⣿⣿⣿⡘⣿⣿⣿⣿⣿⣿⠿⣶⣶⣾⣿⣿⡆⢻⣿⣿⠃⢠⠖⠛⣛⣷⠀\n"
"⠀⠀⢸⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣮⣝⡻⠿⠿⢃⣄⣭⡟⢀⡎⣰⡶⣪⣿⠀\n"
"⠀⠀⠘⣿⣿⣿⠟⣛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⡿⢁⣾⣿⢿⣿⣿⠏⠀\n"
"⠀⠀⠀⣻⣿⡟⠘⠿⠿⠎⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣵⣿⣿⠧⣷⠟⠁⠀⠀\n"
"⡇⠀⠀⢹⣿⡧⠀⡀⠀⣀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⢰⣿⠀⠀⠀⠀\n"
"⡇⠀⠀⠀⢻⢰⣿⣶⣿⡿⠿⢂⣿⣿⣿⣿⣿⣿⣿⢿⣻⣿⣿⣿⡏⠀⠀⠁⠀⠀⠀⠀\n"
"⣷⠀⠀⠀⠀⠈⠿⠟⣁⣴⣾⣿⣿⠿⠿⣛⣋⣥⣶⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀ ⣿⡀\n", "⡿⠋⠄⣀⣀⣤⣴⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣌⠻⣿⣿\n"
"⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠹⣿\n"
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠹\n"
"⣿⣿⡟⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡛⢿⣿⣿⣿⣮⠛⣿⣿⣿⣿⣿⣿⡆\n"
"⡟⢻⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣣⠄⡀⢬⣭⣻⣷⡌⢿⣿⣿⣿⣿⣿\n"
"⠃⣸⡀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠈⣆⢹⣿⣿⣿⡈⢿⣿⣿⣿⣿\n"
"⠄⢻⡇⠄⢛⣛⣻⣿⣿⣿⣿⣿⣿⣿⣿⡆⠹⣿⣆⠸⣆⠙⠛⠛⠃⠘⣿⣿⣿⣿\n"
"⠄⠸⣡⠄⡈⣿⣿⣿⣿⣿⣿⣿⣿⠿⠟⠁⣠⣉⣤⣴⣿⣿⠿⠿⠿⡇⢸⣿⣿⣿\n"
"⠄⡄⢿⣆⠰⡘⢿⣿⠿⢛⣉⣥⣴⣶⣿⣿⣿⣿⣻⠟⣉⣤⣶⣶⣾⣿⡄⣿⡿⢸\n"
"⠄⢰⠸⣿⠄⢳⣠⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣼⣿⣿⣿⣿⣿⣿⡇⢻⡇⢸\n"
"⢷⡈⢣⣡⣶⠿⠟⠛⠓⣚⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢸⠇⠘\n"
"⡀⣌⠄⠻⣧⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⢿⣿⣿⣿⣿⣿⡟⠘⠄⠄\n"
"⣷⡘⣷⡀⠘⣿⣿⣿⣿⣿⣿⣿⣿⡋⢀⣠⣤⣶⣶⣾⡆⣿⣿⣿⠟⠁⠄⠄⠄⠄\n"
"⣿⣷⡘⣿⡀⢻⣿⣿⣿⣿⣿⣿⣿⣧⠸⣿⣿⣿⣿⣿⣷⡿⠟⠉⠄⠄⠄⠄⡄⢀\n"
"⣿⣿⣷⡈⢷⡀⠙⠛⠻⠿⠿⠿⠿⠿⠷⠾⠿⠟⣛⣋⣥⣶⣄⠄⢀⣄⠹⣦⢹⣿\n", "⣿⣿⣿⣿⣯⣿⣿⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠈⣿⣿⣿⣿⣿⣿⣆⠄\n"
"⢻⣿⣿⣿⣾⣿⢿⣢⣞⣿⣿⣿⣿⣷⣶⣿⣯⣟⣿⢿⡇⢃⢻⣿⣿⣿⣿⣿⢿⡄\n"
"⠄⢿⣿⣯⣏⣿⣿⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣧⣾⢿⣮⣿⣿⣿⣿⣾⣷\n"
"⠄⣈⣽⢾⣿⣿⣿⣟⣄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣝⣯⢿⣿⣿⣿⣿\n"
"⣿⠟⣫⢸⣿⢿⣿⣾⣿⢿⣿⣿⢻⣿⣿⣿⢿⣿⣿⣿⢸⣿⣼⣿⣿⣿⣿⣿⣿⣿\n"
"⡟⢸⣟⢸⣿⠸⣷⣝⢻⠘⣿⣿⢸⢿⣿⣿⠄⣿⣿⣿⡆⢿⣿⣼⣿⣿⣿⣿⢹⣿\n"
"⡇⣿⡿⣿⣿⢟⠛⠛⠿⡢⢻⣿⣾⣞⣿⡏⠖⢸⣿⢣⣷⡸⣇⣿⣿⣿⢼⡿⣿⣿\n"
"⣡⢿⡷⣿⣿⣾⣿⣷⣶⣮⣄⣿⣏⣸⣻⣃⠭⠄⠛⠙⠛⠳⠋⣿⣿⣇⠙⣿⢸⣿\n"
"⠫⣿⣧⣿⣿⣿⣿⣿⣿⣿⣿⣿⠻⣿⣾⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣹⢷⣿⡼⠋\n"
"⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣿⣿⣿⠄⠄\n"
"⠄⠄⢻⢹⣿⠸⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣼⣿⣿⣿⣿⡟⠄⠄\n"
"⠄⠄⠈⢸⣿⠄⠙⢿⣿⣿⣹⣿⣿⣿⣿⣟⡃⣽⣿⣿⡟⠁⣿⣿⢻⣿⣿⢿⠄⠄\n"
"⠄⠄⠄⠘⣿⡄⠄⠄⠙⢿⣿⣿⣾⣿⣷⣿⣿⣿⠟⠁⠄⠄⣿⣿⣾⣿⡟⣿⠄⠄\n"
"⠄⠄⠄⠄⢻⡇⠸⣆⠄⠄⠈⠻⣿⡿⠿⠛⠉⠄⠄⠄⠄⢸⣿⣇⣿⣿⢿⣿⠄⠄\n", "⣿⠟⣽⣿⣿⣿⣿⣿⢣⠟⠋⡜⠄⢸⣿⣿⡟⣬⢁⠠⠁⣤⠄⢰⠄⠇⢻⢸\n"
"⢏⣾⣿⣿⣿⠿⣟⢁⡴⡀⡜⣠⣶⢸⣿⣿⢃⡇⠂⢁⣶⣦⣅⠈⠇⠄⢸⢸\n"
"⣹⣿⣿⣿⡗⣾⡟⡜⣵⠃⣴⣿⣿⢸⣿⣿⢸⠘⢰⣿⣿⣿⣿⡀⢱⠄⠨⢸\n"
"⣿⣿⣿⣿⡇⣿⢁⣾⣿⣾⣿⣿⣿⣿⣸⣿⡎⠐⠒⠚⠛⠛⠿⢧⠄⠄⢠⣼\n"
"⣿⣿⣿⣿⠃⠿⢸⡿⠭⠭⢽⣿⣿⣿⢂⣿⠃⣤⠄⠄⠄⠄⠄⠄⠄⠄⣿⡾\n"
"⣼⠏⣿⡏⠄⠄⢠⣤⣶⣶⣾⣿⣿⣟⣾⣾⣼⣿⠒⠄⠄⠄⡠⣴⡄⢠⣿⣵\n"
"⣳⠄⣿⠄⠄⢣⠸⣹⣿⡟⣻⣿⣿⣿⣿⣿⣿⡿⡻⡖⠦⢤⣔⣯⡅⣼⡿⣹\n"
"⡿⣼⢸⠄⠄⣷⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣕⡜⡌⡝⡸⠙⣼⠟⢱⠏\n"
"⡇⣿⣧⡰⡄⣿⣿⣿⣿⡿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣋⣪⣥⢠⠏⠄\n"
"⣧⢻⣿⣷⣧⢻⣿⣿⣿⡇⠄⢀⣀⣀⡙⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠂⠄⠄\n"
"⢹⣼⣿⣿⣿⣧⡻⣿⣿⣇⣴⣿⣿⣿⣷⢸⣿⣿⣿⣿⣿⣿⣿⣿⣰⠄⠄⠄\n"
"⣼⡟⡟⣿⢸⣿⣿⣝⢿⣿⣾⣿⣿⣿⢟⣾⣿⣿⣿⣿⣿⣿⣿⣿⠟⠄⡀⡀\n"
"⣿⢰⣿⢹⢸⣿⣿⣿⣷⣝⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠉⠄⠄⣸⢰⡇\n"
"⣿⣾⣹⣏⢸⣿⣿⣿⣿⣿⣷⣍⡻⣛⣛⣛⡉⠁⠄⠄⠄⠄⠄⠄⢀⢇⡏⠄\n", "⢰⡟⣡⡟⣱⣿⡿⠡⢛⣋⣥⣴⣌⢿⣿⣿⣿⣿⣷⣌⠻⢿⣿⣿⣿⣿⣿⣿\n"
"⠏⢼⡿⣰⡿⠿⠡⠿⠿⢯⣉⠿⣿⣿⣿⣿⣿⣿⣷⣶⣿⣦⣍⠻⢿⣿⣿⣿\n"
"⣼⣷⢠⠀⠀⢠⣴⡖⠀⠀⠈⠻⣿⡿⣿⣿⣿⣿⣿⣛⣯⣝⣻⣿⣶⣿⣿⣿\n"
"⣿⡇⣿⡷⠂⠈⡉⠀⠀⠀⣠⣴⣾⣿⣿⣿⣿⣿⣍⡤⣤⣤⣤⡀⠀⠉⠛⠿\n"
"⣿⢸⣿⡅⣠⣬⣥⣤⣴⣴⣿⣿⢿⣿⣿⣿⣿⣿⣟⡭⡄⣀⣉⡀⠀⠀⠀⠀\n"
"⡟⣿⣿⢰⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣶⣦⣈⠀⠀⠀⢀⣶\n"
"⡧⣿⡇⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣾⣿\n"
"⡇⣿⠃⣿⣿⣿⣿⣿⠛⠛⢫⣿⣿⣻⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿\n"
"⡇⣿⠘⡇⢻⣿⣿⣿⡆⠀⠀⠀⠀⠈⠉⠙⠻⠏⠛⠻⣿⣿⣿⣿⣿⣭⡾⢁\n"
"⡇⣿⠀⠘⢿⣿⣿⣿⣧⢠⣤⠀⡤⢀⣠⣀⣀⠀⠀⣼⣿⣿⣿⣿⣿⠟⣁⠉\n"
"⣧⢻⠀⡄⠀⠹⣿⣿⣿⡸⣿⣾⡆⣿⣿⣿⠿⣡⣾⣿⣿⣿⣿⡿⠋⠐⢡⣶\n"
"⣿⡘⠈⣷⠀⠀⠈⠻⣿⣷⣎⠐⠿⢟⣋⣤⣾⣿⣿⣿⡿⠟⣩⠖⢠⡬⠈⠀\n"
"⣿⣧⠁⢻⡇⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⠿⠟⠋⠁⢀⠈⢀⡴⠈⠁⠀⠀\n"
"⠻⣿⣆⠘⣿⠀⠀⣀⡁⠀⠈⠙⠛⠋⠉⠀⠀⠀⠀⡀⠤⠚⠁⠄⣠\n", "⢸⣿⣿⣿⣿⠃⠄⢀⣴⡾⠃⠄⠄⠄⠄⠄⠈⠺⠟⠛⠛⠛⠛⠻⢿⣿⣿⣿⣿⣶⣤⡀⠄\n"
"⢸⣿⣿⣿⡟⢀⣴⣿⡿⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣸⣿⣿⣿⣿⣿⣿⣿⣷\n"
"⢸⣿⣿⠟⣴⣿⡿⡟⡼⢹⣷⢲⡶⣖⣾⣶⢄⠄⠄⠄⠄⠄⢀⣼⣿⢿⣿⣿⣿⣿⣿⣿⣿\n"
"⢸⣿⢫⣾⣿⡟⣾⡸⢠⡿⢳⡿⠍⣼⣿⢏⣿⣷⢄⡀⠄⢠⣾⢻⣿⣸⣿⣿⣿⣿⣿⣿⣿\n"
"⡿⣡⣿⣿⡟⡼⡁⠁⣰⠂⡾⠉⢨⣿⠃⣿⡿⠍⣾⣟⢤⣿⢇⣿⢇⣿⣿⢿⣿⣿⣿⣿⣿\n"
"⣱⣿⣿⡟⡐⣰⣧⡷⣿⣴⣧⣤⣼⣯⢸⡿⠁⣰⠟⢀⣼⠏⣲⠏⢸⣿⡟⣿⣿⣿⣿⣿⣿\n"
"⣿⣿⡟⠁⠄⠟⣁⠄⢡⣿⣿⣿⣿⣿⣿⣦⣼⢟⢀⡼⠃⡹⠃⡀⢸⡿⢸⣿⣿⣿⣿⣿⡟\n"
"⣿⣿⠃⠄⢀⣾⠋⠓⢰⣿⣿⣿⣿⣿⣿⠿⣿⣿⣾⣅⢔⣕⡇⡇⡼⢁⣿⣿⣿⣿⣿⣿⢣\n"
"⣿⡟⠄⠄⣾⣇⠷⣢⣿⣿⣿⣿⣿⣿⣿⣭⣀⡈⠙⢿⣿⣿⡇⡧⢁⣾⣿⣿⣿⣿⣿⢏⣾\n"
"⣿⡇⠄⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢻⠇⠄⠄⢿⣿⡇⢡⣾⣿⣿⣿⣿⣿⣏⣼⣿\n"
"⣿⣷⢰⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢰⣧⣀⡄⢀⠘⡿⣰⣿⣿⣿⣿⣿⣿⠟⣼⣿⣿\n"
"⢹⣿⢸⣿⣿⠟⠻⢿⣿⣿⣿⣿⣿⣿⣿⣶⣭⣉⣤⣿⢈⣼⣿⣿⣿⣿⣿⣿⠏⣾⣹⣿⣿\n"
"⢸⠇⡜⣿⡟⠄⠄⠄⠈⠙⣿⣿⣿⣿⣿⣿⣿⣿⠟⣱⣻⣿⣿⣿⣿⣿⠟⠁⢳⠃⣿⣿⣿\n"
"⠄⣰⡗⠹⣿⣄⠄⠄⠄⢀⣿⣿⣿⣿⣿⣿⠟⣅⣥⣿⣿⣿⣿⠿⠋⠄⠄⣾⡌⢠⣿⡿⠃\n"
"⠜⠋⢠⣷⢻⣿⣿⣶⣾⣿⣿⣿⣿⠿⣛⣥⣾⣿⠿⠟⠛⠉⠄⠄\n", "⣿⣿⣿⣿⡿⠟⠛⠋⠉⠉⠉⠉⠉⠛⠛⠻⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n"
"⣿⣿⠟⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠙⠾⣿⣾⣿⣾⣿⣾⣿⣾⣿\n"
"⠋⡁⠀⠀⠀⠀⠀⢀⠔⠁⠀⠀⢀⠠⠐⠈⠁⠀⠀⠁⠀⠈⠻⢾⣿⣾⣿⣾⣟⣿\n"
"⠊⠀⠀⠀⠀⢀⠔⠃⠀⠀⠠⠈⠁⠀⠀⠀⠀⠀⠀⠆⠀⠀⠄⠀⠙⣾⣷⣿⢿⣿\n"
"⠀⠀⠀⠀⡠⠉⠀⠀⠀⠀⠠⢰⢀⠀⠀⠀⠀⠀⠀⢰⠀⠀⠈⡀⠀⠈⢿⣟⣿⣿\n"
"⠀⠀⢀⡜⣐⠃⠀⠀⠀⣠⠁⡄⠰⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠰⠀⠀⠈⢿⣿⣿\n"
"⠀⢠⠆⢠⡃⠀⠀⠀⣔⠆⡘⡇⢘⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿\n"
"⢀⡆⠀⡼⢣⠀⢀⠌⢸⢠⠇⡇⢘⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿\n"
"⣼⣃⠀⠁⢸⢀⠎⠀⢸⠎⠀⢸⢸⡄⠀⠀⠀⠀⠀⠂⢀⠀⠀⠀⠀⠀⠀⠀⠀⣿\n"
"⠃⡏⠟⣷⣤⠁⠀⠀⠸⠀⠀⡾⢀⢇⠀⠀⠀⠀⠀⠄⠸⠀⠀⠀⠀⠄⠀⠀⠀⣿\n"
"⠀⠀⣀⣿⣿⣿⢦⠀⠀⠀⠀⡧⠋⠘⡄⠀⠀⠀⠀⡇⢸⠀⠀⠠⡘⠀⠀⠀⢠⣿\n"
"⠈⠀⢿⢗⡻⠃⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⢰⠁⡇⠀⠀⢨⠃⡄⢀⠀⣸⣿\n"
"⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣱⠀⠀⡎⠸⠁⠀⢀⠞⡸⠀⡜⢠⣿⣿\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣺⣿⣧⢰⣧⡁⡄⠀⡞⠰⠁⡸⣠⣿⣿⣿\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡿⠏⣿⠟⢁⠾⢛⣧⢼⠁⠀⠀⢰⣿⡿⣷⣿\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠡⠄⠀⡠⣚⡷⠊⠀⠀⠀⣿⡿⣿⡿⣿\n"
"⡀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠊⠁⢸⠁⠀⠀⠀⢰⣿⣿⡿⣿⣿\n"
"⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠊⠀⠀⠀⡞⠀⠀⠀⠀⢸⣿⣷⣿⣿⣿\n"
"⠀⠙⢦⣀⠀⠀⠀⠀⠀⢀⣀⣠⠖⠁⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⣸⣿⣾⡿⣷⣿\n"
"⠀⠀⠀⠀⠉⠉⣩⡞⠉⠁⠀⢸⡄⠀⠀⠀⠀⠀⢰⠇⠀⠀⠀⠀⣿⣿⣷⣿⣿⣿\n"
"⡆⠀⠀⣀⡠⠞⠁⣧⢤⣀⣀⣀⡇⠀⠀⠀⠀⠀⣸⠀⠀⠀⠀⠀⣿⣷⣿⣷⣿⣿\n"
"⣿⣷⠊⠁⠀⠀⡰⠁⠀⠀⠀⠀⣹⠶⢦⡀⠀⠀⡇⠀⠀⠀⠀⠀⢸⣿⣷⣿⣷⣿\n"
"⣿⢿⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⡄⡇⠀⠀⠀⠀⠀⠈⣿⣾⣷⣿⣿\n"
"⠋⠈⠀⢀⠜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠈⣧⠀⠀⠀⠀⠀⠀⠻⣿⣽⣾⣿\n"
"⢀⡄⡠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠁⠀⠀⠀⣸⠀⠀⠀⠀⠀⠀⠀⣿⣿⣻⣿\n"
"⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⢰⠀⠐⠀⠀⠀⠀⣀⡿⠀⠀⠀⠀⠀⠀⠀⢹⣿⣻⣿\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⢀⣃⡇⠀⠲⡀⠀⠀⠀⠀⠈⣿⡿⣿\n"
"⣀⠤⠤⠤⡀⠀⠀⠀⠀⡴⠃⠀⠀⠀⠀⠀⢬⠞⡇⠀⠀⠇⠀⠀⠀⠀⠀⣿⣿⣿\n"
"⡁⢀⠀⠀⡇⠀⠀⠀⡼⠁⠀⠀⠀⠀⠀⣸⠁⠀⠇⠀⠀⡇⠀⠀⠀⠀⠀⣿⣿⣿\n"
"⠔⠃⠀⠀⡇⠀⠀⡼⠁⠀⠀⠀⠀⠀⢀⡇⠀⠀⡃⠀⠀⠙⢄⠀⠀⠀⠀⣿⣷⣿\n"
"⠒⠊⠀⠀⢸⠀⣸⠃⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⢅⠀⠀⡂⠸⡄⠀⠀⠀⣿⣟⣿\n"
"⠓⠀⠉⠀⢸⣰⠃⠀⠀⠀⠀⠀⠀⡜⡆⠀⠀⠀⢸⠀⠀⡇⢀⠇⠀⠀⠀⣿⣿⣿\n"
"⠉⠁⠀⢠⠞⠀⠀⠀⠀⠀⠀⠀⣰⠁⡇⠀⠀⠀⡇⠀⠀⡇⢸⠀⠀⠀⠀⣿⣷⣿\n"
"⡀⠀⢀⢿⣥⡤⠤⠤⠤⣀⣀⢠⠇⠀⢸⠀⠀⢰⠁⠀⢨⠀⢸⠀⠀⠀⠀⣿⣟⣿\n", "⠄⣾⣿⡇⢸⣿⣿⣿⠄⠈⣿⣿⣿⣿⠈⣿⡇⢹⣿⣿⣿⡇⡇⢸⣿⣿⡇⣿⣿⣿\n"
"⢠⣿⣿⡇⢸⣿⣿⣿⡇⠄⢹⣿⣿⣿⡀⣿⣧⢸⣿⣿⣿⠁⡇⢸⣿⣿⠁⣿⣿⣿\n"
"⢸⣿⣿⡇⠸⣿⣿⣿⣿⡄⠈⢿⣿⣿⡇⢸⣿⡀⣿⣿⡿⠸⡇⣸⣿⣿⠄⣿⣿⣿\n"
"⢸⣿⡿⠷⠄⠿⠿⠿⠟⠓⠰⠘⠿⣿⣿⡈⣿⡇⢹⡟⠰⠦⠁⠈⠉⠋⠄⠻⢿⣿\n"
"⢨⡑⠶⡏⠛⠐⠋⠓⠲⠶⣭⣤⣴⣦⣭⣥⣮⣾⣬⣴⡮⠝⠒⠂⠂⠘⠉⠿⠖⣬\n"
"⠈⠉⠄⡀⠄⣀⣀⣀⣀⠈⢛⣿⣿⣿⣿⣿⣿⣿⣿⣟⠁⣀⣤⣤⣠⡀⠄⡀⠈⠁\n"
"⠄⠠⣾⡀⣾⣿⣧⣼⣿⡿⢠⣿⣿⣿⣿⣿⣿⣿⣿⣧⣼⣿⣧⣼⣿⣿⢀⣿⡇⠄\n"
"⡀⠄⠻⣷⡘⢿⣿⣿⡿⢣⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣜⢿⣿⣿⡿⢃⣾⠟⢁⠈\n"
"⢃⢻⣶⣬⣿⣶⣬⣥⣶⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣷⣶⣶⣾⣿⣷⣾⣾⢣\n"
"⡄⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠘\n"
"⣿⡐⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢠⢃\n"
"⣿⣷⡀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⡿⠋⢀⠆⣼\n"
"⣿⣿⣷⡀⠄⠈⠛⢿⣿⣿⣿⣿⣷⣶⣶⣶⣶⣶⣿⣿⣿⣿⣿⠿⠋⠠⠂⢀⣾⣿\n"
"⣿⣿⣿⣧⠄⠄⢵⢠⣈⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⢋⡁⢰⠏⠄⠄⣼⣿⣿\n"
"⢻⣿⣿⣿⡄⢢⠨⠄⣯⠄⠄⣌⣉⠛⠻⠟⠛⢋⣉⣤⠄⢸⡇⣨⣤⠄⢸⣿⣿⣿\n", "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀   ⣤⣶⣶⣶⣶⣶⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⢿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣿⣿⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⡇⣿⣷⣿⣿⣿⣿⣿⣿⣯⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⣿⣿⣿⣇⣿⣀⠸⡟⢹⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢡⣿⣿⣿⡇⠝⠋⠀⠀⠀⢿⢿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢸⠸⣿⣿⣇⠀⠀⠀⠀⠀⠀⠊⣽⣿⣿⣿⠁⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣷⣄⠀⠀⠀⢠⣴⣿⣿⣿⠋⣠⡏⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠾⣿⣟⡻⠉⠀⠀⠀⠈⢿⠋⣿⡿⠚⠋⠁⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣶⣾⣿⣿⡄⠀⣳⡶⡦⡀⣿⣿⣷⣶⣤⡾⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡆⠀⡇⡿⠉⣺⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣯⠽⢲⠇⠣⠐⠚⢻⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⡐⣾⡏⣷⠀⠀⣼⣷⡧⣿⣿⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣻⣿⣿⣿⣿⣿⣮⠳⣿⣇⢈⣿⠟⣬⣿⣿⣿⣿⣿⡦⢄⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢄⣾⣿⣿⣿⣿⣿⣿⣿⣷⣜⢿⣼⢏⣾⣿⣿⣿⢻⣿⣝⣿⣦⡑⢄⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⣠⣶⣷⣿⣿⠃⠘⣿⣿⣿⣿⣿⣿⣿⡷⣥⣿⣿⣿⣿⣿⠀⠹⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⣇⣤⣾⣿⣿⡿⠻⡏⠀⠀⠸⣿⣿⣿⣿⣿⣿⣮⣾⣿⣿⣿⣿⡇⠀⠀⠙⣿⣿⡿⡇⠀⠀⠀⠀⠀\n"
"⠀⠀⢀⡴⣫⣿⣿⣿⠋⠀⠀⡇⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⢘⣿⣿⣟⢦⡸⠀⠀⠀\n"
"⠀⡰⠋⣴⣿⣟⣿⠃⠀⠀⠀⠈⠀⠀⣸⣿⣿⣿⣿⣿⣿⣇⣽⣿⣿⣿⣿⣇⠀⠀⠀⠁⠸⣿⢻⣦⠉⢆⠀⠀\n"
"⢠⠇⡔⣿⠏⠏⠙⠆⠀⠀⠀⠀⢀⣜⣛⡻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⡀⠀⠀⠀⠀⡇⡇⠹⣷⡈⡄⠀\n"
"⠀⡸⣴⡏⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⡇⡇⠀⢻⡿⡇⠀\n"
"⠀⣿⣿⣆⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⣰⠿⠤⠒⡛⢹⣿⠄\n"
"⠀⣿⣷⡆⠁⠀⠀⠀⠀⢠⣿⣿⠟⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠻⢷⡀⠀⠀⠀⠀⠀⣸⣿⠀\n"
"⠀⠈⠿⢿⣄⠀⠀⠀⢞⠌⡹⠁⠀⠀⢻⡇⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⢳⠀⠀⠁⠀⠀⠀⠀⢠⣿⡏⠀\n"
"⠀⠀⠀⠈⠂⠀⠀⠀⠈⣿⠁⠀⠀⠀⡇⠁⠀⠘⢿⣿⣿⠿⠟⠋⠛⠛⠛⠀⢸⠀⠀⡀⠂⠀⠀⠐⠛⠉⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠕⣠⡄⣰⡇⠀⠀⠀⢸⣧⠀⠀⠀⠀⠀⠀⠀⢀⣸⠠⡪⠊⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢫⣽⡋⠭⠶⠮⢽⣿⣆⠀⠀⠀⠀⢠⣿⣓⣽⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n"
"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⢹⣶⣦⣾⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀\n", "⣿⡇⠘⡇⢀⣶⣶⠄⠈⣾⡟⢂⣿⣿⣿⣿⣿⣿⡿⢉⢾⢃⣿⣿⡟⣸⢸⣿⣿⣸\n"
"⣿⢸⣦⢧⢸⣿⣿⢱⠄⠄⣇⣼⣿⣿⣿⣿⣿⢟⣼⣿⡯⠸⣿⢳⢱⡏⣼⣿⢇⣿\n"
"⡏⣾⢽⣼⢸⣿⣿⡘⣆⢀⠛⣿⣿⣿⣿⡿⣫⣾⣿⣿⢇⣿⠂⢌⡾⡇⣿⡿⢸⣿\n"
"⢧⣿⠄⢹⢸⣿⣿⣷⣭⢸⡄⣿⣿⣿⢋⣵⣿⣿⡿⠟⡨⡡⠄⣾⣿⡆⣭⡇⣿⣿\n"
"⣼⡏⡀⠄⢀⢿⣿⣿⡟⣾⡇⣿⡿⣡⢁⣿⣿⣫⡶⢃⡵⣡⣿⣮⡻⡇⣿⢸⣮⢿\n"
"⣿⡇⣧⢠⠸⡎⡍⡭⢾⡏⣧⢋⢾⠏⣼⣿⣿⠿⣵⣾⣕⠿⣿⣿⣷⢡⠏⣾⣿⣿\n"
"⣿⠁⣿⠈⠄⠄⢃⢹⡀⠸⢸⢿⠸⢰⢻⢿⣟⢁⣀⠄⠄⠉⠒⢝⢿⠸⣴⣿⣿⣿\n"
"⡍⠇⣿⣷⢰⢰⢸⠄⡃⡆⠈⠈⡀⡌⠠⠸⠃⣿⣏⡳⢷⢄⡀⠄⠄⠰⣿⣿⣿⣿\n"
"⡇⠄⠸⣿⢸⣿⣶⡄⣇⠃⡇⡄⡇⠁⠃⠄⠈⢊⠻⠿⣿⣿⣿⣦⠄⠘⣿⣿⣿⣿\n"
"⡇⠄⠄⢻⣸⣿⣿⠏⡙⢸⣇⣡⢰⢀⠄⠄⠄⠈⡁⢱⢈⢿⣿⡿⡄⣰⣶⣿⣿⣿\n"
"⡇⠄⠄⠄⢻⣿⡿⢰⡇⠆⠲⠶⣝⠾⠸⢴⢠⠄⠇⢸⢸⠄⡶⡜⣽⣿⣿⣿⣿⢏\n"
"⠁⠄⠄⠄⠄⢿⡇⠧⢣⣸⣦⣄⣀⠁⠓⢸⣄⠸⢀⠄⡀⡀⡪⣽⣿⣿⢿⣿⢟⣬\n"
"⠄⠄⠄⠄⠄⠈⢧⠯⢸⣿⣿⣿⡿⠰⣷⠄⣿⣇⡿⠄⡀⠦⣰⣿⡿⣱⣿⡏⢾⣫\n"
"⠄⠄⠄⠄⠄⠄⠈⣌⢌⢿⣿⣿⠇⠼⢃⢠⢇⣻⣧⣿⡡⣸⣿⠿⢁⡟⢁⣳⣿⣿\n"
"⠄⠄⠄⠄⠄⠄⠄⠄⠳⢝⣒⣒⠰⣘⣴⡧⠿⣿⣛⡯⣱⡿⣫⢎⣪⣎⣿⣧⢻⠿\n", "⣿⡟⠙⠛⠋⠩⠭⣉⡛⢛⠫⠭⠄⠒⠄⠄⠄⠈⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n"
"⣿⡇⠄⠄⠄⠄⣠⠖⠋⣀⡤⠄⠒⠄⠄⠄⠄⠄⠄⠄⠄⠄⣈⡭⠭⠄⠄⠄⠉⠙\n"
"⣿⡇⠄⠄⢀⣞⣡⠴⠚⠁⠄⠄⢀⠠⠄⠄⠄⠄⠄⠄⠄⠉⠄⠄⠄⠄⠄⠄⠄⠄\n"
"⣿⡇⠄⡴⠁⡜⣵⢗⢀⠄⢠⡔⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄\n"
"⣿⡇⡜⠄⡜⠄⠄⠄⠉⣠⠋⠠⠄⢀⡄⠄⠄⣠⣆⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢸\n"
"⣿⠸⠄⡼⠄⠄⠄⠄⢰⠁⠄⠄⠄⠈⣀⣠⣬⣭⣛⠄⠁⠄⡄⠄⠄⠄⠄⠄⢀⣿\n"
"⣏⠄⢀⠁⠄⠄⠄⠄⠇⢀⣠⣴⣶⣿⣿⣿⣿⣿⣿⡇⠄⠄⡇⠄⠄⠄⠄⢀⣾⣿\n"
"⣿⣸⠈⠄⠄⠰⠾⠴⢾⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⢁⣾⢀⠁⠄⠄⠄⢠⢸⣿⣿\n"
"⣿⣿⣆⠄⠆⠄⣦⣶⣦⣌⣿⣿⣿⣿⣷⣋⣀⣈⠙⠛⡛⠌⠄⠄⠄⠄⢸⢸⣿⣿\n"
"⣿⣿⣿⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠈⠄⠄⠄⠄⠄⠈⢸⣿⣿\n"
"⣿⣿⣿⠄⠄⠄⠘⣿⣿⣿⡆⢀⣈⣉⢉⣿⣿⣯⣄⡄⠄⠄⠄⠄⠄⠄⠄⠈⣿⣿\n"
"⣿⣿⡟⡜⠄⠄⠄⠄⠙⠿⣿⣧⣽⣍⣾⣿⠿⠛⠁⠄⠄⠄⠄⠄⠄⠄⠄⠃⢿⣿\n"
"⣿⡿⠰⠄⠄⠄⠄⠄⠄⠄⠄⠈⠉⠩⠔⠒⠉⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠐⠘⣿\n"
"⣿⠃⠃⠄⠄⠄⠄⠄⠄⣀⢀⠄⠄⡀⡀⢀⣤⣴⣤⣤⣀⣀⠄⠄⠄⠄⠄⠄⠁⢹\n", "⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⢻⣿⣿⣿⣿⣿⣿⣿⣿⣯⢻⣿⣿⣿⣿⣆⠄⠄⠄\n"
"⠄⠄⣼⢀⣿⣿⣿⣿⣏⡏⠄⠹⣿⣿⣿⣿⣿⣿⣿⣿⣧⢻⣿⣿⣿⣿⡆⠄⠄\n"
"⠄⠄⡟⣼⣿⣿⣿⣿⣿⠄⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⣿⣇⢻⣿⣿⣿⣿⠄⠄\n"
"⠄⢰⠃⣿⣿⠿⣿⣿⣿⠄⠄⠄⠄⠄⠄⠙⠿⣿⣿⣿⣿⣿⠄⢿⣿⣿⣿⡄⠄\n"
"⠄⢸⢠⣿⣿⣧⡙⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠈⠛⢿⣿⣿⡇⠸⣿⡿⣸⡇⠄\n"
"⠄⠈⡆⣿⣿⣿⣿⣦⡙⠳⠄⠄⠄⠄⠄⠄⢀⣠⣤⣀⣈⠙⠃⠄⠿⢇⣿⡇⠄\n"
"⠄⠄⡇⢿⣿⣿⣿⣿⡇⠄⠄⠄⠄⠄⣠⣶⣿⣿⣿⣿⣿⣿⣷⣆⡀⣼⣿⡇⠄\n"
"⠄⠄⢹⡘⣿⣿⣿⢿⣷⡀⠄⢀⣴⣾⣟⠉⠉⠉⠉⣽⣿⣿⣿⣿⠇⢹⣿⠃⠄\n"
"⠄⠄⠄⢷⡘⢿⣿⣎⢻⣷⠰⣿⣿⣿⣿⣦⣀⣀⣴⣿⣿⣿⠟⢫⡾⢸⡟⠄⠄\n"
"⠄⠄⠄⠄⠻⣦⡙⠿⣧⠙⢷⠙⠻⠿⢿⡿⠿⠿⠛⠋⠉⠄⠂⠘⠁⠞⠄⠄⠄\n"
"⠄⠄⠄⠄⠄⠈⠙⠑⣠⣤⣴⡖⠄⠿⣋⣉⣉⡁⠄⢾⣦⠄⠄⠄⠄⠄⠄⠄⠄\n", "⡟⢻⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣣⠄⡀⢬⣭⣻⣷⡌⢿⣿⣿⣿⣿⣿\n"
"⠃⣸⡀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠈⣆⢹⣿⣿⣿⡈⢿⣿⣿⣿⣿ \n"
"⠄⢻⡇⠄⢛⣛⣻⣿⣿⣿⣿⣿⣿⣿⣿⡆⠹⣿⣆⠸⣆⠙⠛⠛⠃⠘⣿⣿⣿⣿ \n"
"⠄⠸⣡⠄⡈⣿⣿⣿⣿⣿⣿⣿⣿⠿⠟⠁⣠⣉⣤⣴⣿⣿⠿⠿⠿⡇⢸⣿⣿⣿ \n"
"⠄⡄⢿⣆⠰⡘⢿⣿⠿⢛⣉⣥⣴⣶⣿⣿⣿⣿⣻⠟⣉⣤⣶⣶⣾⣿⡄⣿⡿⢸ \n"
"⠄⢰⠸⣿⠄⢳⣠⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣼⣿⣿⣿⣿⣿⣿⡇⢻⡇⢸ \n"
"⢷⡈⢣⣡⣶⠿⠟⠛⠓⣚⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢸⠇⠘ \n"
"⡀⣌⠄⠻⣧⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠛⠛⠛⢿⣿⣿⣿⣿⣿⡟⠘⠄⠄ \n"
"⣷⡘⣷⡀⠘⣿⣿⣿⣿⣿⣿⣿⣿⡋⢀⣠⣤⣶⣶⣾⡆⣿⣿⣿⠟⠁⠄⠄⠄⠄ \n"
"⣿⣷⡘⣿⡀⢻⣿⣿⣿⣿⣿⣿⣿⣧⠸⣿⣿⣿⣿⣿⣷⡿⠟⠉⠄⠄⠄⠄⡄⢀ \n"
"⣿⣿⣷⡈⢷⡀⠙⠛⠻⠿⠿⠿⠿⠿⠷⠾⠿⠟⣛⣋⣥⣶⣄⠄⢀⣄⠹⣦⢹\n", "⣿⣧⣿⣿⣿⣿⡟⢸⣿⣿⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⣏⣿⣿\n"
"⣿⢸⣿⡏⣿⣿⣹⢸⣿⣿⣿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿\n"
"⣿⢼⡟⣤⣿⣧⣿⣸⣿⣿⣿⣿⣿⣿⣿⢻⣸⣿⢿⣿⣿⣿⣿⣿⣿⡇\n"
"⣿⢸⢧⣽⡼⣟⣛⣃⣿⠿⣿⣿⣿⣿⣿⢸⣏⣿⡘⣿⣿⣿⣿⡿⣿⢳\n"
"⣿⡜⣸⡿⠷⠿⢿⣿⡼⡟⣼⡿⣿⣿⡿⡼⣿⣞⣆⡄⢭⢟⣻⡇⡿⣾\n"
"⡜⣷⢻⣤⣿⡒⠄⠄⠉⣺⣿⣿⣾⣽⣇⣥⡯⠿⠾⣞⣮⣃⢻⣧⣇⣿\n"
"⣿⣮⡞⣷⣯⣗⣙⣿⣧⣣⣿⣿⣿⣿⣿⣿⣇⠟⡂⣀⣀⠉⡫⢸⣸⣿\n"
"⢿⣿⣿⣮⡻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣷⣬⣍⣎⣿⣿\n"
"⣦⣭⣟⡿⣿⣿⣝⢿⣿⣿⣿⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣜⣼⣿⣿\n"
"⠋⠄⠄⠄⠄⠉⠻⢷⣝⡿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⣼⣿⣿⣿\n"
"⠄⠄⠄⠄⠄⠄⠄⠄⢙⢿⣮⡻⣿⣷⣿⣿⠿⣟⡯⢡⣾⣠⣿⣿⣿⣿\n", "⣿⣿⠟⣁⠤⠒⠉⠁⠀⠀⠀⠀⠀⠂⠂⠙⢿⣿⣿⣿⣿⣿⣿\n"
"⣿⢣⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿\n"
"⢧⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⢰⡦⣠⡟⢿⣿⣿⣿\n"
"⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣼⡟⣿⢇⠸⣿⣿⣿\n"
"⠃⠀⠀⠀⢀⡄⠀⠀⠀⣄⠀⠀⣰⡄⠀⠀⠑⡹⢦⣄⠀⠀⠉⠛\n"
"⠀⠀⠀⠀⢸⣹⡄⣧⡀⢸⠆⠀⠐⢠⠀⠀⠀⠀♡\n"
"⠀⠀⠀⠀⢘⣿⣿⣿⣧⣿⣧⣴⣄⣠⣇⡀⣦ 𝒽𝒶𝓋𝑒\n"
"⠀⠀⠀⠀⠘⣿⠟⠉⡻⣿⣿⣿⣿⣿⣿⣿⡟ 𝒶\n"
"⡄⡀⠀⠀⠀⠉⠀⢤⣄⣹⣿⣿⣿⣿⣿⣿⠃ 𝓁𝑜𝓋𝑒𝓁𝓎\n"
"⣧⣷⡠⡀⠀⢀⣄⠀⠙⢿⣿⣿⣿⣿⡿⠃⠀ 𝒹𝒶𝓎\n"
"⣿⣿⣷⣿⣦⣾⣿⡀⠀⠀⠀⠀⠀⢉⣴⣶⣤⣀♡\n"
"⣿⣿⣿⣿⣿⣿⣿⡇⠀⢠⠀⠀⣴⣿⣿⣿⣿⣿⣿⣶⡄\n"
"⣿⣿⣿⣿⣿⣿⣿⡇⠀⢸⡆⢸⣿⣿⣿⣿⣿⣿⣿⣿⠃\n"
"⣿⣿⣿⣿⣿⣿⣿⡇⠀⢸⡇⠘⣿⣿⣿⣿⣿⣿⣿⡙\n"
"⣿⣿⣿⣿⣿⣿⣿⡇⠀⢸⡇⠀⢹⣿⣿⣿⣿⣿⡏\n", "⣿⣿⣿⣿⣿⣿⣿⣟⡛⠉⠉⠛⡛⠻⠿⣿⣿⣿⣿⣿\n"
"⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⢠⣼⣷⣦⣀⠙⠻⣿⣿\n"
"⣿⣿⣿⣿⣿⣏⠉⠀⠀⠈⠁⢸⣿⣿⣿⣿⣷⡄⠈⢿\n"
"⣿⣿⣿⣿⣿⣿⠀⠀⣴⣷⠀⠘⢿⣿⣿⣿⣿⣿⡄⠀⢻\n"
"⣿⣿⣿⣿⣿⣿⠀⠀⠀⠻⠀⢳⣌⠻⣿⣿⣿⣿⣿⠀⠈\n"
"⣿⣿⣿⣿⣿⡋⠀⠀⠀⢰⣦⠈⠛⠷⡌⢻⣿⣿⣿⠀⠀\n"
"⣿⣿⣿⣿⡿⠁⠀⡄⠀⢸⣿⡄⠑⢶⣤⣈⢻⣿⣿⠀⠀\n"
"⣿⣿⣿⣿⠁⠀⠚⠃⠀⠈⣁⣠⣤⣄⡙⣿⣧⣿⠇⠀⢰\n"
"⣿⣟⢿⣿⣤⣤⣶⣾⣇⠀⢹⣿⣿⣿⣇⣿⡿⠃⠀⣠\n"
"⣿⣿⣧⣙⠻⣿⣿⣿⣿⡄⢸⣿⣿⣿⠟⠋⠀⢀⣴⣿\n"
"⣿⣿⣿⣿⣷⣤⣈⡉⠙⠃⠘⠉⠉⢀⣀⣤⣾⣿⣿⣿\n"
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢹⣿⣿⣿⣿⣿⣿⣿⣿\n"
"⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⣼⣿⣿⣿⣿⣿⣿⣿⣿\n", "⢀⢀⢀⢸⢀⠙⢦⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡰⢢⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡾⢸⡀⢀⠉⠲⢤⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣠⠴⠒⠋⡄⢸⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡇⢀⢧⢀⢀⢀⢀⠈⠓⠦⣄⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⡤⠖⠋⠉⢀⢀⢀⡰⡁⢀⡇⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡇⢀⡎⢧⢀⢀⢀⢀⢀⢀⢀⠙⢦⡀⢀⢀⢀⢀⣀⣀⡤⠤⠤⠤⠤⠤⢤⣀⣀⡀⢀⢀⢀⡴⠚⠁⢀⢀⢀⢀⢀⢀⢠⠃⡇⢀⡇⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡇⢀⡇⠈⢧⢀⢀⢀⢀⢀⢀⢀⢀⠙⠒⠊⠉⠉⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠈⠉⠛⠁⢀⢀⢀⢀⢀⢀⢀⢀⡠⠃⢀⣇⢀⡇⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡧⠊⠁⢀⢀⢣⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡸⠁⢀⢀⢀⠙⢇⢀⢀⢀⢀⢀\n"
"⢀⡠⠊⢀⢀⢀⢀⢀⢀⠑⢄⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡴⠁⢀⢀⢀⢀⢀⢀⠑⣄⢀⢀⢀⢀⢀⢀⢀⢀⢀⡴⠁⡀⢀⢀⢀⢀⢀⡩⠂⢀⢀⢀\n"
"⠑⠦⢄⣀⢀⢀⢀⢀⢀⢀⠈⠳⡄⢀⢀⢀⢀⢀⢀⢀⢀⢀⡞⢀⢀⢀⢀⢀⢀⢀⢀⢀⠘⡆⢂⢀⢀⢀⢀⢀⠠⡎⢀⢀⠘⣄⡠⢤⠖⠉⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⠈⣏⢳⠒⡀⢀⢀⢀⡔⠁⢀⢀⢀⢀⢀⢀⢀⢀⠘⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠸⡸⡀⢀⢀⢀⢀⢀⠈⢆⢀⢀⡇⡜⡸⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⠘⡌⢆⡇⢀⢀⠎⢀⢀⢀⢀⢀⢀⢀⢠⠏⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡇⢄⢀⢀⢀⢀⢀⠘⡄⢠⢱⢡⠃⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡖⠒⠼⡈⢇⢀⡞⢀⢀⢀⢀⢀⢀⢀⢠⠇⢀⢸⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡇⠈⡆⢀⢀⢀⢀⢀⣙⡜⢡⠇⢀⠔⢢⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡇⢀⢀⢨⠊⡮⠚⠉⠉⢱⢀⢀⢀⢀⠎⢀⢀⡜⡄⢠⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡆⢸⠇⢀⢸⡀⢀⢀⢀⢠⠃⠈⠺⡰⠁⢀⢸⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢳⢀⢀⡇⢸⠁⢀⢀⢀⠎⢀⢀⢀⡜⢀⢀⡞⢀⣣⠬⢆⡀⢀⢀⢀⢀⢀⢀⢀⡰⠥⡎⢰⡀⢀⢇⢀⢀⢀⠘⡄⢀⢀⢸⡆⢀⡜⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡇⢀⡠⠣⡄⢀⢀⢀⡎⢀⢀⢀⢠⠃⢀⠎⢀⢀⠣⢄⣀⡇⢸⢀⢀⢀⢀⠰⣃⢀⡠⠜⢀⢳⡀⠈⢀⢀⢀⢀⢱⢀⢀⢸⡇⢀⠸⡀⢀⢀⢀⢀\n"
"⢀⢀⡀⡕⠊⢀⡸⠈⢆⡀⢀⡇⢀⢀⢀⢸⡰⠋⢀⢀⢀⢀⡀⠑⠵⡌⢆⢀⢀⢀⡣⠂⠁⡀⢀⢀⢀⠹⡄⡆⢀⢀⢀⠸⡄⢠⠃⡌⠒⢴⡁⢀⢀⢀⢀\n"
"⢀⢀⣑⣶⡄⣼⡜⣀⢸⣿⡜⢀⢀⢀⢀⠈⣤⠖⢋⠝⠛⡒⢌⠂⢀⠈⠪⢄⡠⠊⢀⢀⢪⢔⡞⠻⡓⠦⡈⢳⢀⢀⢀⢀⡏⡇⢀⠹⡄⢀⠬⠗⢀⢀⢀\n"
"⠴⣾⡟⢁⣼⣿⣿⠇⣿⣿⢇⢀⢀⢀⢀⢸⡇⢀⡇⢠⡄⢸⠁⢀⢀⢀⢀⢀⢀⢀⢀⢀⠃⡏⢠⡄⢱⢀⡇⡼⢀⢀⢸⢀⡇⣇⢾⡷⣮⡘⢿⣦⣀⢀⢀\n"
"⢀⢀⠸⡿⣝⣾⡿⣠⣿⣿⠘⡆⢀⢀⢀⠈⡅⢀⠑⢄⡠⠊⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠣⣀⣀⠜⠐⢡⠃⢀⢠⠎⢀⢸⣿⠸⣿⡜⣿⣦⣙⠿⠓⠂\n"
"⢀⢀⢀⢱⠉⠁⢀⠙⣿⡇⢀⠘⢆⢀⢀⢀⢳⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡎⢀⢀⠎⢀⢀⢸⣿⠦⡿⠿⠈⢻⠋⢀⢀⢀\n"
"⢀⢀⢀⠘⡆⢀⢀⢀⠘⢀⢇⢀⢀⠑⠼⣦⢀⢣⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠰⢀⢀⢀⢀⢀⢀⢀⢠⢞⣀⠔⠁⢀⢀⡄⡌⠁⢠⠃⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⠘⡄⢀⢀⢢⡀⠈⢣⡀⢀⢀⠘⣍⠢⠵⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠉⢹⠃⢀⢀⢀⡜⡰⡁⢀⠎⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⠈⠢⡑⢄⢏⠂⢀⠙⠢⡀⢀⠸⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⢀⢀⢀⢀⢀⢀⢀⢀⠎⢀⢀⡠⠊⡴⢡⠓⠁⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⢀⢀⠈⠒⢥⢀⡰⡀⢰⡈⠑⢆⢳⢄⡀⢀⢀⢀⢀⢀⢀⠒⠉⠈⠑⢀⢀⢀⢀⢀⣠⠋⢀⠔⠉⣠⠞⠊⠁⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠗⠁⠘⡼⠈⠢⡀⢹⡀⠙⠢⣄⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣠⠔⠊⠸⢖⡅⡠⠊⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠈⠊⠈⠑⠒⡇⠈⠑⠢⠤⣀⢀⢀⡠⢴⣉⡠⠔⡹⠔⠁⠸⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⣷⣤⣀⢀⢀⢀⠉⠈⢀⢸⠤⣀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣀⠤⠒⠉⠉⢀⠈⠛⠿⣿⣶⠒⠒⠒⣾⠿⢀⢀⠉⠒⠤⣀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢀⢀⠤⠔⠒⠒⠒⠒⠉⣽⠋⠁⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠈⠉⠉⠉⢀⢀⢀⢀⢀⢀⢀⢀⠉⠒⢲⡦⠤⢄⣀⣀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⢠⠃⢀⢀⢀⢀⢀⢀⢸⡇⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⡠⠒⢒⡢⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢹⡄⢀⢀⢀⠉⠢⡀⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡎⢀⢀⢀⢀⢀⢀⢀⢸⡇⢀⠉⠑⠒⠢⠤⠤⢄⣀⣀⢀⢀⢇⢴⣿⢃⠇⢀⢀⢀⣀⣀⠤⠒⠊⠁⢀⢸⡇⢀⢀⢀⢀⢀⢹⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢸⢀⢀⢀⢀⢀⢀⢀⢀⠸⡇⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠉⠑⡼⣱⠲⡝⣄⠒⠉⠉⢀⢀⢀⢀⢀⢀⢀⢸⠇⢀⢀⢀⢀⢀⢸⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⡇⢀⢀⢀⢀⢀⢀⢀⢀⣇⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⣼⢡⡏⢀⠻⡌⢷⣄⢀⢀⢀⢀⢀⢀⢀⢀⣼⢀⢀⢀⢀⢀⢀⢸⢀⢀⢀⢀⢀⢀⢀\n"
"⢀⢀⢀⠁⢀⢀⢀⢀⢀⢀⢀⢀⠉⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠉⠁⠉⢀⢀⢀⠉⢀⠉⠁⢀⢀⢀⢀⢀⢀⢀⠉⢀⢀⢀⢀⢀⢀⠉⢀⢀⢀⢀⢀⢀⢀\n", "⣿⣿⣿⣿⣿⣿⣿⣿⢿⠟⢿⣿⣿⣿⣿⠿⠛⠛⠿⢿⣿⣿⣿⣿⠛⣿⢿⣿⣿⣿⣿⣿\n"
"⣿⣿⣿⣿⡿⢿⣿⣿⣄⠄⣼⣿⡿⠋⠄⠄⠄⠄⠄⠄⠄⠛⣿⣿⠄⢀⣤⣿⣿⣿⣿⣿\n"
"⣿⣿⣿⣷⣤⣸⣿⠛⡛⢛⣿⠋⠄⠄⢀⠄⠄⠄⠄⠄⠄⠄⠘⣿⣿⡿⣿⣿⣿⣿⣿⣿\n"
"⣿⣿⣿⣿⣿⡿⠁⠄⠁⠈⠄⠄⠄⠄⣿⡀⠄⠄⠄⠄⠄⠄⠄⠓⠸⠏⠄⢹⣿⣿⣿⣿\n"
"⣿⣿⣿⣿⡿⠄⠄⠄⠄⠄⠄⠄⢠⠿⠿⢻⣦⣤⣠⠄⠄⠄⠄⠄⠄⠄⠄⠈⠻⣿⣿⣿\n"
"⣿⣿⣿⡿⠁⠄⠄⠄⠄⠈⠄⠄⢸⣿⣿⣿⣿⣿⢭⡛⡀⠄⠄⠨⠄⠄⠄⠄⠄⣿⣿⣿\n"
"⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠻⣧⡀⣈⣿⣿⠟⠄⠄⠠⢇⠄⠄⠄⠄⠄⣿⣿⣿\n"
"⣿⣿⡁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⢀⣉⡉⠉⠄⠄⠄⠄⠄⠰⠂⠄⠄⠄⠄⢹⣿⣿\n"
"⣿⣿⡇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⠿⠁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠘⣿⣿\n"
"⣿⣿⣿⣶⣤⣤⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣼⣿⣿\n"
};
const char* Version::asciiArtsCP437[] = {
"#################*********++++=*+++==========+++++\n"
"#####################*******+*+*+++========+++*+**\n"
"\%\%\%\%\%\%\%\%###############*******+*+===:==+++++++****\n"
"\%\%\%\%\%\%\%\%\%\%\%\%########****++++++++*+++++++++++******\n"
"\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%#***********#***********++*******#\n"
"\%\%\%\%\%\%\%\%\%\%\%\%\%\%\%#****#***#####***#**###********####\n"
"\%\%\%\%\%\%\%\%\%\%\%\%\%\%#*###\%#######\%#+=+*=#+*+*==**#######\n"
"\%\%\%\%\%\%\%\%\%\%\%\%\%##########\%\%\%\%\%\%#####\%\%\%\%#\%##########\n"
"\%\%\%\%\%\%\%\%\%\%\%\%\%#####\%####\%\%\%\%\%\%\%##\%#\%\%#\%\%#\%###******\n"
"##########\%\%\%###\%\%\%###\%\%\%#\%*\%\%#\%\%##\%*\%\%\%\%\%##******\n"
"######****#####\%\%\%\%#\%#\%\%*+==\%\%\%\%\%#=*:#\%\%\%\%\%##***##\n"
"#######*#####\%\%\%\%\%\%###\%#-=::+\%\%##+=*+*#\%\%\%\%##****#\n"
"#############\%\%\%#\%\%####:...:-###=:=#+**\%\%\%\%#######\n"
"######****+**\%\%\%.+\%###:....:.++..-#\%*:=\%\%\%\%#*#####\n"
"######*****##\%\%\%.-####:......:....::..+\%\%\%\%#*#####\n"
"****#*****+==+#\%+:#\%##-.:.:.......::::*\%\%\%#**#####\n"
"---:::::::::...*\%##\%##-..............:#\%\%#***#####\n"
"*+=============++*\%\%\%#=.....--=-:....=\%\%\%****#####\n"
"*****************+*\%\%#*:...:-::::..:*\%\%\%#****#####\n"
"****#*###**********#\%\%#*--........*##\%\%##****#####\n"
"****#*###########*+#\%\%#*+-----=*-:-*\%#*##****#####\n"
"**#*##############-*#\%\%#=-=--=+\%#*#########**#####\n"
"##################+-#####======###=#########**####\n"
"#######\%###########.###*************########**####\n"
"########\%\%#########-********#####*****######***###\n"
"+....:*#\%\%\%###\%####*******##*#*###*****#####***###\n"
"+.....*###\%\%#######******##******##***######****##\n", "\xB0\xB0\xB0\xDB\xDB\xDB\xDB\xDD\xDB\xDB\xDB\xDB\xDB\xDD\xDB\xB0\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDE\xDF\xDB\xDB\xDF\n"
"\xB0\xDC\xDB\xDB\xDB\xDB\xDB\xB0\xDB\xDB\xDB\xDB\xDB\xDD\xB0\xDB\xB0\xDF\xDB\xDB\xDB\xDB\xDB\xDB\xDD\xDB\xDC\xDC\xDF\xDC\n"
"\xB0\xDD\xDB\xDB\xDB\xDD\xDB\xB0\xDE\xDB\xDB\xDB\xDD\xDD\xB0\xB0\xDC\xDC\xB0\xDD\xDB\xDD\xDB\xDB\xDB\xDE\xDB\xDB\xDB\xB0\xDF\n"
"\xDE\xB0\xDE\xDB\xDB\xB0\xB0\xDC\xDC\xDE\xDF\xDB\xB0\xB0\xB0\xDE\xDC\xDB\xDF\xDD\xDB\xDE\xDB\xDB\xDB\xDE\xDB\n"
"\xB0\xB0\xDB\xDB\xDB\xB0\xDD\xDC\xDB\xDD\xB0\xB0\xDF\xB0\xB0\xDF\xDB\xDB\xB0\xB0\xDF\xDB\xDB\xDB\xDB\xDB\xDB\xDD\n"
"\xB0\xB0\xB0\xDF\xDB\xDD\xDF\xDB\xDB\xDF\xB0\xDC\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDB\xDB\xDB\xDE\xDB\xDB\xDB\n"
"\xB0\xB0\xB0\xB0\xDB\xDB\xDD\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDE\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDD\n"
"\xB0\xB0\xB0\xB0\xDB\xDB\xDB\xB0\xB0\xB0\xB0\xB0\xDF\xDB\xDF\xB0\xB0\xB0\xB0\xB0\xDE\xDB\xDB\xDE\xDB\xDB\xDB\xDF\xDD\n"
"\xB0\xB0\xB0\xB0\xDD\xDB\xDD\xDB\xDC\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDC\xDC\xDB\xDB\xDB\xDB\xDF\xB0\xDF\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xDB\xDF\xDB\xDB\xDC\xDC\xDC\xB0\xDC\xDC\xDF\xDF\xB1\xDB\xDF\xDB\xB0\n", "\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDC\xDC\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDC\xDC\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDC\xDF\xDF\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDC\xDC\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xDC\xDF\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDC\n"
"\xB0\xB0\xB0\xB0\xB0\xDD\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDC\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDF\xDC\n"
"\xB0\xB0\xB0\xB0\xDD\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDD\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDD\n"
"\xB0\xB0\xB0\xDE\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB1\xB0\xB0\xB0\xB0\xB0\xDD\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDE\n"
"\xB0\xB0\xB0\xDD\xDE\xB0\xB0\xB0\xB0\xDE\xB0\xB0\xB0\xB0\xDE\xB1\xB1\xB0\xB0\xB0\xB0\xB0\xDD\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDD\n"
"\xB0\xB0\xDE\xB0\xDD\xB0\xB0\xB0\xB0\xDD\xB0\xB0\xDE\xB0\xDD\xB1\xB1\xB1\xB0\xB0\xB0\xDE\xB0\xB0\xB0\xB0\xB0\xB1\xB0\xDD\xDE\xB0\xDE\n"
"\xB0\xB0\xDE\xB0\xDD\xB1\xB0\xB0\xB0\xDD\xDC\xDC\xDF\xDF\xDD\xDD\xB1\xB1\xB0\xB1\xB0\xDE\xDF\xDD\xDF\xDD\xDC\xB1\xB0\xDE\xB1\xDD\xB0\xDD\n"
"\xB0\xB0\xB0\xDD\xDD\xB0\xB1\xB0\xB0\xDE\xDF\xDC\xDD\xDD\xDE\xDE\xB1\xB1\xB1\xB1\xDE\xDE\xDE\xB1\xDE\xB1\xDD\xDD\xB0\xDE\xB1\xDD\xDC\xDE\n"
"\xB0\xDC\xDF\xDC\xDE\xB1\xB1\xB1\xB0\xDD\xDD\xDC\xDF\xDC\xDE\xB0\xDD\xDD\xB1\xDE\xB0\xDD\xDC\xDF\xDC\xB0\xDE\xB1\xB0\xDE\xB1\xDD\xB0\xDF\xDC\n"
"\xDF\xDC\xDF\xB1\xB1\xDD\xB1\xB1\xDC\xDF\xB0\xDD\xDB\xDE\xB0\xB0\xDE\xDE\xDF\xB0\xB0\xB0\xDD\xDB\xDE\xB0\xDF\xDC\xDE\xB1\xDD\xDD\xB0\xB0\xB0\xDF\n"
"\xB0\xDF\xDF\xDC\xDC\xDE\xB1\xDF\xDC\xDF\xB0\xDF\xDC\xDF\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDC\xDF\xDC\xDF\xB1\xDD\xB0\xDE\n"
"\xB0\xB0\xB0\xB0\xDF\xDE\xDF\xDC\xB1\xDF\xDC\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDE\xB0\xB0\xB0\xB0\xB0\xB0\xDF\xDD\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xDD\xB1\xDD\xDE\xB1\xDF\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDE\xB1\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xDE\xB0\xDE\xB1\xDD\xB0\xB0\xB0\xB0\xDC\xDC\xDF\xDF\xDF\xDF\xDC\xB0\xB0\xB0\xB0\xDD\xB1\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDD\xDE\xB1\xDE\xDC\xB0\xB0\xB0\xDE\xB1\xB1\xB1\xB1\xB1\xDD\xB0\xB0\xDC\xDF\xB1\xB0\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xDE\xB0\xB0\xDD\xDE\xDE\xDF\xDC\xB0\xB0\xDF\xDC\xDC\xDC\xDF\xB0\xDC\xDF\xDE\xB1\xB0\xB0\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xDD\xDD\xB0\xDD\xDE\xB0\xDD\xB1\xDF\xDC\xDC\xB0\xB0\xB0\xB0\xDC\xDD\xDE\xB0\xDD\xB1\xB0\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xDE\xB1\xDE\xB0\xDE\xDE\xB0\xDD\xB1\xB1\xB1\xB1\xDF\xDF\xDC\xDF\xDD\xDE\xB0\xB0\xDD\xB1\xB0\xDD\n"
"\xB0\xB0\xB0\xB0\xB0\xDD\xB1\xB1\xDD\xDE\xB1\xDD\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xDE\xDF\xDC\xDD\xB0\xDE\xB1\xB1\n", "\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDB\xDE\xB2\xB2\xB0\xDB\xDB\xDB\xDB\xDC\xDC\xDC\xDB\xDF\xDC\xB2\xB2\xB2\xDD\xDB\n"
"\xB0\xB0\xB0\xB0\xB0\xDC\xDB\xDD\xDF\xDC\xB2\xB2\xDC\xDC\xDC\xDC\xDF\xDF\xDF\xDC\xB2\xB2\xB2\xB2\xB2\xDD\xDB\n"
"\xB0\xB0\xB0\xDC\xDB\xDF\xDF\xDC\xB2\xDB\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xDF\xB0\xB2\xDD\xDB\n"
"\xB0\xB0\xDB\xDF\xDC\xB2\xB2\xB2\xDB\xDB\xDB\xB2\xB2\xB2\xDB\xDB\xDB\xB2\xB2\xB2\xDC\xB0\xB0\xDC\xB2\xDE\xDB\xDD\n"
"\xB0\xDB\xDD\xB2\xB2\xB2\xDF\xDF\xB2\xB2\xB2\xB2\xDB\xDB\xDB\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xDC\xDF\xB2\xB2\xDE\xDB\n"
"\xDE\xDB\xDE\xDB\xDB\xDE\xB0\xDC\xB2\xB2\xB2\xB2\xB2\xDF\xDC\xB0\xDF\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xDD\xDB.\n"
"\xDB\xDD\xDB\xDB\xDB\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xDE\xB0\xB0\xDC\xB2\xB2\xDB\xDB\xDB\xB2\xB2\xB2\xDC\xDF\xDE\xDB\n"
"\xDB\xDE\xDB\xB2\xDF\xB0\xB0\xDF\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xDB\xDB\xDB\xDB\xDB\xDB\xB2\xB2\xB2\xB2\xDE\xDB\n"
"\xDD\xB2\xDC\xDD\xDF\xB0\xDF\xB0\xDE\xDF\xDB\xDC\xB2\xB2\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xDB\xB2\xB2\xB2\xDD\xDB\xDD\n"
"\xDD\xB2\xB2\xB2\xDC\xDC\xDF\xDF\xB2\xB2\xB2\xDF\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xB2\xDB\xB2\xDB\xB2\xDB\xB2\xB2\xDD\xDB\xDD\n"
"\xDB\xDE\xB2\xB2\xB2\xB2\xB2\xB2\xDC\xDC\xDC\xB2\xB2\xB2\xB2\xB2\xB2\xDB\xB2\xDB\xB2\xDB\xB2\xDB\xB2\xB2\xB2\xDE\xDB\n", "\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDC\xDC\xB0\xB0\xB0\xDC\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDC\xDC\xDC\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xDC\xDD\xDB\xDB\xB0\xDB\xDB\xDE\n"
"\xB0\xB0\xB0\xB0\xDC\xDC\xB0\xDC\xDF\xDF\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xDF\xB1\xDF\xDC\xDB\xDB\n"
"\xB0\xB0\xB0\xDE\xDE\xDB\xDF\xB1\xB1\xDC\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xDF\xB1\xDD\n"
"\xB0\xB0\xB0\xDD\xDB\xDB\xDB\xDC\xDB\xDB\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xDF\xDE\n"
"\xB0\xB0\xDB\xB1\xB1\xDB\xDF\xDB\xDB\xDB\xDD\xB1\xB1\xB1\xB1\xDE\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB1\xB0\xB1\xB0\xB0\xDB\n"
"\xB0\xDE\xB1\xB1\xDB\xDD\xDE\xDD\xDF\xDF\xB1\xB0\xB1\xB0\xB1\xDD\xDD\xB1\xB0\xB1\xB0\xB1\xB1\xDB\xB1\xB0\xB0\xB0\xB0\xB0\xDD\n"
"\xB0\xDE\xB1\xB1\xDF\xB1\xDE\xDB\xB0\xB0\xB0\xB0\xB0\xB0\xDB\xB0\xDC\xDF\xB0\xB0\xB0\xB0\xDE\xB0\xDB\xB1\xB1\xB1\xB1\xB1\xDE\n"
"\xB0\xDD\xB0\xB0\xB0\xB1\xB0\xB1\xDD\xB1\xB0\xB1\xB0\xDE\xB0\xDF\xDE\xB1\xB1\xB0\xB1\xB0\xDD\xB0\xB0\xDB\xB1\xB1\xDD\xB1\xDE\xDC\n"
"\xB0\xDD\xB1\xB0\xB1\xB0\xB0\xDE\xB1\xB1\xB1\xB1\xB1\xDD\xB0\xB0\xB0\xDD\xB1\xDE\xDE\xDE\xDC\xDF\xDF\xDF\xDD\xB1\xDD\xB1\xDD\xDD\xDF\n"
"\xDE\xB1\xB1\xB1\xB1\xB1\xB1\xDE\xB1\xDD\xB1\xB1\xDE\xDC\xDF\xDF\xDE\xDE\xB1\xDD\xB1\xDD\xB1\xDD\xB1\xDC\xB1\xDD\xDD\xB1\xDB\xDE\n"
"\xDE\xB1\xB1\xB1\xB1\xB1\xB1\xDD\xB1\xDE\xB1\xB1\xDD\xDD\xB1\xDB\xDC\xB0\xDF\xB0\xB0\xB0\xB0\xDF\xDF\xDF\xDF\xDE\xDE\xDE\xB0\xDD\n"
"\xDD\xB1\xB1\xB1\xB1\xB1\xDE\xB1\xB1\xB1\xDF\xDC\xB0\xDF\xDF\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDE\xB1\xDD\n"
"\xDF\xDE\xB1\xDC\xB1\xB1\xDD\xDE\xDE\xB1\xB1\xB1\xDD\xDC\xB0\xB0\xB0\xB0\xB0\xDF\xDC\xDF\xB0\xB0\xB0\xDC\xDF\xB1\xDD\xDD\n"
"\xB0\xB0\xDE\xB0\xDF\xDF\xB0\xDE\xB1\xDD\xB1\xB1\xDE\xB1\xDF\xDC\xDC\xDC\xDC\xDC\xDC\xDC\xDC\xDF\xDE\xB1\xB1\xDE\xB0\xDE\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDB\xDE\xB1\xDC\xDF\xDC\xDD\xDB\xDC\xDC\xDC\xDF\xDF\xDB\xB0\xB0\xB0\xDB\xDC\xDF\xDD\n"
"\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xB0\xDB\xDF\xDF\xDF\xB0\xDF\xDF\xDB\xDF\xDB\xDF\xDF\xDB\xDF\xDF\xDF\xDF\xDC\n"
};
const int Version::asciiArtCountUTF8 = sizeof(asciiArtsUTF8) / sizeof(asciiArtsUTF8[0]);
const int Version::asciiArtCountCP437 = sizeof(asciiArtsCP437) / sizeof(asciiArtsCP437[0]); bool Version::useUTF8Art = false; void Version::InitAsciiArt(bool isWin7OrLater) {
useUTF8Art = isWin7OrLater; }
std::string Version::GetRandomAsciiArt() {
srand((unsigned int)time(NULL));
if (useUTF8Art) {
int index = rand() % asciiArtCountUTF8;
return std::string(asciiArtsUTF8[index]); } else {
int index = rand() % asciiArtCountCP437;
return std::string(asciiArtsCP437[index]); }
}
bool Version::IsValid() {
std::string expireStr = GetExpireDate(); time_t now = time(0); struct tm expireTm; memset(&expireTm, 0, sizeof(expireTm)); sscanf(expireStr.c_str(), "%d-%d-%d %d:%d:%d", &expireTm.tm_year, &expireTm.tm_mon, &expireTm.tm_mday, &expireTm.tm_hour, &expireTm.tm_min, &expireTm.tm_sec); expireTm.tm_year -= 1900; expireTm.tm_mon -= 1; time_t expireTime = mktime(&expireTm);
return now < expireTime; }
int Version::GetDaysUntilExpire() {
if (!IsValid()) return 0; time_t now = time(0); struct tm expireTm; memset(&expireTm, 0, sizeof(expireTm)); std::string expireStr = GetExpireDate(); sscanf(expireStr.c_str(), "%d-%d-%d", &expireTm.tm_year, &expireTm.tm_mon, &expireTm.tm_mday); expireTm.tm_year -= 1900; expireTm.tm_mon -= 1; time_t expireTime = mktime(&expireTm); double seconds = difftime(expireTime, now);
return (int)(seconds / 86400); }
```

### 20. src\utils\version.h

```c
#pragma once
#include <string>
class Version {
public:
static const char* GetVersion() { return "1.0.0"; }
static const char* GetBuildDate() { return __DATE__ " " __TIME__; }
static const char* GetExpireDate() { return "2027-12-31 23:59:59"; }
static const char* GetAuthor() { return "Makoto"; }
static bool IsValid(); static int GetDaysUntilExpire(); static void InitAsciiArt(bool isWin7OrLater); static std::string GetRandomAsciiArt();
private:
static const char* asciiArtsUTF8[]; static const char* asciiArtsCP437[]; static const int asciiArtCountUTF8; static const int asciiArtCountCP437; static const int asciiArtCount; static bool useUTF8Art; };
```

### 21. src\main.cpp

```cpp
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>
#include <psapi.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <iostream>
#include <sstream>
#include <iomanip>
#include "core/resource_monitor.h"
#include "core/config_manager.h"
#include "core/cpu_worker.h"
#include "core/memory_worker.h"
#include "platform/system_tray.h"
#include "platform/autostart.h"
#include "utils/console_utils.h"
#include "utils/version.h"
#include "utils/system_info.h"
#ifdef _MSC_VER
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "psapi.lib")
#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "pdh.lib")
#endif
volatile LONG g_running = 1; volatile LONG g_show_window = 1; ConfigManager* g_config = nullptr; ResourceMonitor* g_monitor = nullptr; CPUWorker* g_cpu_worker = nullptr; MemoryWorker* g_memory_worker = nullptr; SystemTray* g_tray = nullptr; BOOL WINAPI ConsoleHandler(DWORD signal) {
if (signal == CTRL_C_EVENT || signal == CTRL_CLOSE_EVENT) {
InterlockedExchange(&g_running, 0);
return TRUE; }
return FALSE; }
void ParseCommandLine(int argc, char* argv[]) {
for (int i = 1; i < argc; i++) {
std::string arg = argv[i];
if (arg == "-h" || arg == "--help") {
ConsoleUtils::ShowHelp(); exit(0); } else if (arg == "-v" || arg == "--version") {
ConsoleUtils::ShowVersion(); exit(0); } else if (arg == "-auto") {
ConsoleUtils::Init();
if (AutoStart::Enable()) {
ConsoleUtils::PrintSuccess(
ConsoleUtils::IsWindows7OrLater() ?
"自启动已启用" : "Auto-start enabled"); } else {
ConsoleUtils::PrintError(
ConsoleUtils::IsWindows7OrLater() ?
"启用自启动失败" : "Failed to enable auto-start"); }
exit(0); } else if (arg == "-noauto") {
ConsoleUtils::Init();
if (AutoStart::Disable()) {
ConsoleUtils::PrintSuccess(
ConsoleUtils::IsWindows7OrLater() ?
"自启动已禁用" : "Auto-start disabled"); } else {
ConsoleUtils::PrintError(
ConsoleUtils::IsWindows7OrLater() ?
"禁用自启动失败" : "Failed to disable auto-start"); }
exit(0); } else if (arg == "-window" && i + 1 < argc) {
std::string value = argv[++i]; InterlockedExchange(&g_show_window, (value == "true" || value == "1" || value == "yes" || value == "on") ? 1 : 0); } else if (arg == "-cpu" && i + 1 < argc) {
int cpuThreshold = atoi(argv[++i]);
if (cpuThreshold >= 0 && cpuThreshold <= 100) {
g_config->SetCPUThreshold(cpuThreshold); }
} else if (arg == "-mem" && i + 1 < argc) {
int memThreshold = atoi(argv[++i]);
if (memThreshold >= 0 && memThreshold <= 100) {
g_config->SetMemoryThreshold(memThreshold); }
} else if (arg == "-c" && i + 1 < argc) {
g_config->SetConfigPath(argv[++i]); }
}
}
void MonitorLoop() {
DWORD last_update = GetTickCount(); bool last_cpu_worker_state = false; bool last_mem_worker_state = false; int cpu_start_count = 0; int cpu_stop_count = 0; int mem_start_count = 0; int mem_stop_count = 0; int confirm_threshold = SystemInfo::IsWindows7OrLater() ? 2 : 3; MSG msg;
while (g_running) {
while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
TranslateMessage(&msg); DispatchMessage(&msg); }
DWORD now = GetTickCount(); DWORD elapsed_ms = now - last_update;
if (elapsed_ms >= (DWORD)(g_config->GetUpdateInterval() * 1000)) {
last_update = now; double total_cpu = g_monitor->GetCPUUsage(); double total_mem = g_monitor->GetMemoryUsage(); int cpu_threshold = g_config->GetCPUThreshold(); int mem_threshold = g_config->GetMemoryThreshold(); double cpu_worker_usage = 0;
if (g_cpu_worker && g_cpu_worker->IsRunning()) {
cpu_worker_usage = g_cpu_worker->GetUsage(); }
double other_cpu_usage = total_cpu - cpu_worker_usage;
if (other_cpu_usage < 0) other_cpu_usage = 0; int hysteresis = 5; bool should_cpu_work;
if (last_cpu_worker_state) {
should_cpu_work = other_cpu_usage < (cpu_threshold + hysteresis); } else {
should_cpu_work = other_cpu_usage < (cpu_threshold - hysteresis); }
if (should_cpu_work != last_cpu_worker_state) {
if (should_cpu_work) {
cpu_start_count++; cpu_stop_count = 0;
if (cpu_start_count >= confirm_threshold) {
if (g_cpu_worker) {
g_cpu_worker->Start();
if (g_show_window) {
ConsoleUtils::PrintInfo(
ConsoleUtils::IsWindows7OrLater() ?
"[CPU] 其他程序占用 %.1f%% < 阈值 %d%%，开始CPU计算" :
"[CPU] Other %.1f%% < threshold %d%%, starting", other_cpu_usage, cpu_threshold); }
}
last_cpu_worker_state = true; cpu_start_count = 0; }
} else {
cpu_stop_count++; cpu_start_count = 0;
if (cpu_stop_count >= confirm_threshold) {
if (g_cpu_worker) {
g_cpu_worker->Stop();
if (g_show_window) {
ConsoleUtils::PrintInfo(
ConsoleUtils::IsWindows7OrLater() ?
"[CPU] 其他程序占用 %.1f%% >= 阈值 %d%%，停止CPU计算" :
"[CPU] Other %.1f%% >= threshold %d%%, stopping", other_cpu_usage, cpu_threshold); }
}
last_cpu_worker_state = false; cpu_stop_count = 0; }
}
} else {
cpu_start_count = 0; cpu_stop_count = 0; }
if (last_cpu_worker_state && g_cpu_worker && g_cpu_worker->IsRunning()) {
double target_cpu_worker_usage = cpu_threshold - other_cpu_usage;
if (target_cpu_worker_usage < 0) target_cpu_worker_usage = 0;
if (target_cpu_worker_usage > 100) target_cpu_worker_usage = 100; g_cpu_worker->AdjustLoad(cpu_worker_usage, target_cpu_worker_usage); }
double mem_worker_usage = 0;
if (g_memory_worker && g_memory_worker->IsRunning()) {
mem_worker_usage = g_memory_worker->GetUsage(); }
double other_mem_usage = total_mem - mem_worker_usage;
if (other_mem_usage < 0) other_mem_usage = 0; bool should_mem_work;
if (last_mem_worker_state) {
should_mem_work = other_mem_usage < (mem_threshold + hysteresis); } else {
should_mem_work = other_mem_usage < (mem_threshold - hysteresis); }
if (should_mem_work != last_mem_worker_state) {
if (should_mem_work) {
mem_start_count++; mem_stop_count = 0;
if (mem_start_count >= confirm_threshold) {
if (g_memory_worker) {
g_memory_worker->Start();
if (g_show_window) {
ConsoleUtils::PrintInfo(
ConsoleUtils::IsWindows7OrLater() ?
"[MEM] 其他程序占用 %.1f%% < 阈值 %d%%，开始内存计算" :
"[MEM] Other %.1f%% < threshold %d%%, starting", other_mem_usage, mem_threshold); }
}
last_mem_worker_state = true; mem_start_count = 0; }
} else {
mem_stop_count++; mem_start_count = 0;
if (mem_stop_count >= confirm_threshold) {
if (g_memory_worker) {
g_memory_worker->Stop();
if (g_show_window) {
ConsoleUtils::PrintInfo(
ConsoleUtils::IsWindows7OrLater() ?
"[MEM] 其他程序占用 %.1f%% >= 阈值 %d%%，停止内存计算" :
"[MEM] Other %.1f%% >= threshold %d%%, stopping", other_mem_usage, mem_threshold); }
}
last_mem_worker_state = false; mem_stop_count = 0; }
}
} else {
mem_start_count = 0; mem_stop_count = 0; }
if (last_mem_worker_state && g_memory_worker && g_memory_worker->IsRunning()) {
double target_mem_worker_usage = mem_threshold - other_mem_usage;
if (target_mem_worker_usage < 0) target_mem_worker_usage = 0;
if (target_mem_worker_usage > 80) target_mem_worker_usage = 80; g_memory_worker->AdjustLoad(mem_worker_usage, target_mem_worker_usage); }
if (g_tray) {
char tooltip[256]; snprintf(tooltip, sizeof(tooltip), "MikaBooM\nCPU: %.1f%% / %d%%\nMEM: %.1f%% / %d%%", total_cpu, cpu_threshold, total_mem, mem_threshold); g_tray->UpdateTooltip(tooltip); }
if (g_show_window) {
ConsoleUtils::PrintStatus(
total_cpu, total_mem, g_cpu_worker && g_cpu_worker->IsRunning(), g_memory_worker && g_memory_worker->IsRunning(), g_cpu_worker ? g_cpu_worker->GetIntensity() : 0, g_memory_worker ? (size_t)(g_memory_worker->GetAllocatedSize() / 1024 / 1024) : 0
); }
}
Sleep(100); }
}
int main(int argc, char* argv[]) {
SetConsoleCtrlHandler(ConsoleHandler, TRUE); INITCOMMONCONTROLSEX icex; icex.dwSize = sizeof(INITCOMMONCONTROLSEX); icex.dwICC = ICC_STANDARD_CLASSES; InitCommonControlsEx(&icex); g_config = new ConfigManager(); g_config->Load(); ConsoleUtils::Init(); ParseCommandLine(argc, argv);
if (!g_show_window) {
FreeConsole(); } else {
ConsoleUtils::ShowWelcome(); bool useUTF8 = ConsoleUtils::IsWindows7OrLater();
if (useUTF8) {
printf(">> CPU阈值: %d%%\n", g_config->GetCPUThreshold()); printf(">> 内存阈值: %d%%\n", g_config->GetMemoryThreshold()); } else {
printf("CPU Threshold: %d%%\n", g_config->GetCPUThreshold()); printf("Memory Threshold: %d%%\n", g_config->GetMemoryThreshold()); }
printf("\n"); }
if (!Version::IsValid()) {
if (g_show_window) {
ConsoleUtils::PrintWarning(
ConsoleUtils::IsWindows7OrLater() ?
"版本已过期，仅监控模式" :
"Version expired, monitoring mode only"); }
g_config->SetEnableWorker(false); }
g_monitor = new ResourceMonitor();
if (g_config->GetEnableWorker() && Version::IsValid()) {
g_cpu_worker = new CPUWorker(g_config->GetCPUThreshold()); g_memory_worker = new MemoryWorker(g_config->GetMemoryThreshold()); }
g_tray = new SystemTray();
if (!g_tray->Create()) {
if (g_show_window) {
ConsoleUtils::PrintError(
ConsoleUtils::IsWindows7OrLater() ?
"创建系统托盘图标失败" :
"Failed to create system tray icon"); }
}
if (g_config->GetAutoStart()) {
AutoStart::Enable(); }
if (g_show_window) {
ConsoleUtils::PrintSuccess(
ConsoleUtils::IsWindows7OrLater() ?
"程序启动成功，开始监控..." :
"Started successfully, monitoring..."); printf("\n"); }
MonitorLoop();
if (g_show_window) {
ConsoleUtils::PrintInfo(
ConsoleUtils::IsWindows7OrLater() ?
"正在清理资源..." :
"Cleaning up resources..."); }
if (g_cpu_worker) {
g_cpu_worker->Stop(); delete g_cpu_worker; g_cpu_worker = nullptr; }
if (g_memory_worker) {
g_memory_worker->Stop(); delete g_memory_worker; g_memory_worker = nullptr; }
if (g_tray) {
g_tray->Destroy(); delete g_tray; g_tray = nullptr; }
if (g_monitor) {
delete g_monitor; g_monitor = nullptr; }
if (g_config) {
g_config->Save(); delete g_config; g_config = nullptr; }
if (g_show_window) {
ConsoleUtils::PrintSuccess(
ConsoleUtils::IsWindows7OrLater() ?
"程序已安全退出" :
"Exited safely"); }
return 0; }
```

### 22. .gitignore

```text
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
MikaBooM
MikaBooM-*
# Test binary
*.test
# Output of go coverage
*.out
# Build directory
dist/
build/
# C++ build artifacts
*.o
*.obj
*.exe
*.out
*.a
*.lib
*.msvc
# IDE
.vscode/
.idea/
*.swp
*.swo
*~
# OS
.DS_Store
Thumbs.db
# Config (optional, uncomment if you want to ignore config)
# config.yaml
```

### 23. config.ini

```ini
; MikaBooM Configuration File
; Generated by MikaBooM C++ Edition
[General]
cpu_threshold=35
memory_threshold=60
auto_start=true
show_window=true
update_interval=2
[Notification]
enabled=true
cooldown=60
```

### 24. Makefile

```text
# MikaBooM C++ Edition Makefile
# 支持 MinGW - 静态链接
CXX = g++
RC = windres
TARGET = MikaBooM.exe
SRCDIR = src
RESDIR = res
OBJDIR = build
# 编译标志 - 基础静态链接
CXXFLAGS = -std=c++11 -Wall -O2 \
           -static-libgcc -static-libstdc++ \
           -D_WIN32_WINNT=0x0500 \
           -DWINVER=0x0500
# 链接标志 - 静态链接 C++ 运行库，确保包含 PDH
LDFLAGS = -static-libgcc -static-libstdc++ \
          -Wl,-Bstatic -lstdc++ -lpthread -Wl,-Bdynamic \
          -lkernel32 -luser32 -lshell32 -ladvapi32 \
          -lpsapi -lcomctl32 -lpdh \
          -mconsole
# 源文件
SOURCES = $(SRCDIR)/main.cpp \
          $(SRCDIR)/core/resource_monitor.cpp \
          $(SRCDIR)/core/config_manager.cpp \
          $(SRCDIR)/core/cpu_worker.cpp \
          $(SRCDIR)/core/memory_worker.cpp \
          $(SRCDIR)/platform/system_tray.cpp \
          $(SRCDIR)/platform/autostart.cpp \
          $(SRCDIR)/utils/console_utils.cpp \
          $(SRCDIR)/utils/version.cpp
RESOURCE = $(RESDIR)/resource.rc
OBJECTS = $(SOURCES:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)
RESOBJECT = $(OBJDIR)/resource.o
# 默认目标
all: directories $(TARGET)
# 创建目录
directories:
	@if not exist $(OBJDIR) mkdir $(OBJDIR)
	@if not exist $(OBJDIR)\core mkdir $(OBJDIR)\core
	@if not exist $(OBJDIR)\platform mkdir $(OBJDIR)\platform
	@if not exist $(OBJDIR)\utils mkdir $(OBJDIR)\utils
# 链接
$(TARGET): $(OBJECTS) $(RESOBJECT)
	@echo ========================================
	@echo Linking $(TARGET)...
	@echo ========================================
	$(CXX) $(OBJECTS) $(RESOBJECT) -o $@ $(LDFLAGS)
	@echo Stripping symbols to reduce size...
	@strip -s $@
	@echo ========================================
	@echo Build complete: $(TARGET)
	@echo ========================================
	@dir $(TARGET) | findstr $(TARGET)
	@echo ========================================
# 编译源文件
$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
	@echo Compiling $<...
	@$(CXX) $(CXXFLAGS) -c $< -o $@
# 编译资源文件
$(OBJDIR)/resource.o: $(RESOURCE)
	@echo Compiling resources...
	@$(RC) -D_WIN32_WINNT=0x0500 $< -o $@
# 检查依赖项
check: $(TARGET)
	@echo ========================================
	@echo Checking DLL dependencies...
	@echo ========================================
	@objdump -p $(TARGET) | findstr "DLL Name"
	@echo ========================================
# 清理
clean:
	@echo Cleaning build files...
	@if exist $(OBJDIR) rmdir /s /q $(OBJDIR)
	@if exist $(TARGET) del $(TARGET)
	@echo Clean complete.
# 完全重新编译
rebuild: clean all
# 运行
run: $(TARGET)
	$(TARGET)
# 运行测试
test: $(TARGET)
	@echo ========================================
	@echo Testing parameters...
	@echo ========================================
	@echo.
	@echo Test 1: Help
	@echo ----------------------------------------
	@$(TARGET) -h
	@echo.
	@echo Test 2: Version
	@echo ----------------------------------------
	@$(TARGET) -v
	@echo.
	@echo ========================================
.PHONY: all clean rebuild run check test directories
```

### 25. Makefile.msvc

```text
# MikaBooM MSVC NMake Makefile
CC = cl
RC = rc
LINK = link
TARGET = MikaBooM.exe
SRCDIR = src
RESDIR = res
OBJDIR = build
CFLAGS = /c /EHsc /O2 /MT /std:c++11 /Fo$(OBJDIR)\
LFLAGS = /SUBSYSTEM:WINDOWS
LIBS = kernel32.lib user32.lib shell32.lib advapi32.lib psapi.lib comctl32.lib pdh.lib
SOURCES = \
    $(SRCDIR)\main.cpp \
    $(SRCDIR)\core\resource_monitor.cpp \
    $(SRCDIR)\core\config_manager.cpp \
    $(SRCDIR)\core\cpu_worker.cpp \
    $(SRCDIR)\core\memory_worker.cpp \
    $(SRCDIR)\platform\system_tray.cpp \
    $(SRCDIR)\platform\autostart.cpp \
    $(SRCDIR)\utils\console_utils.cpp \
    $(SRCDIR)\utils\version.cpp
OBJECTS = \
    $(OBJDIR)\main.obj \
    $(OBJDIR)\resource_monitor.obj \
    $(OBJDIR)\config_manager.obj \
    $(OBJDIR)\cpu_worker.obj \
    $(OBJDIR)\memory_worker.obj \
    $(OBJDIR)\system_tray.obj \
    $(OBJDIR)\autostart.obj \
    $(OBJDIR)\console_utils.obj \
    $(OBJDIR)\version.obj \
    $(OBJDIR)\resource.res
all: directories $(TARGET)
directories:
	@if not exist $(OBJDIR) mkdir $(OBJDIR)
$(TARGET): $(OBJECTS)
	$(LINK) $(LFLAGS) /OUT:$@ $(OBJECTS) $(LIBS)
{$(SRCDIR)}.cpp{$(OBJDIR)}.obj:
	$(CC) $(CFLAGS) $<
{$(SRCDIR)\core}.cpp{$(OBJDIR)}.obj:
	$(CC) $(CFLAGS) $<
{$(SRCDIR)\platform}.cpp{$(OBJDIR)}.obj:
	$(CC) $(CFLAGS) $<
{$(SRCDIR)\utils}.cpp{$(OBJDIR)}.obj:
	$(CC) $(CFLAGS) $<
$(OBJDIR)\resource.res: $(RESDIR)\resource.rc
	$(RC) /fo$@ $**
clean:
	@if exist $(OBJDIR) rd /s /q $(OBJDIR)
	@if exist $(TARGET) del $(TARGET)
```

### 26. README.md

```markdown
<div align="center">
<img src="./res/icon.png" width="128" height="128" alt="MikaBooM">
<h1>MikaBooM C++ Edition</h1>
</div>
跨平台系统资源监控与调整工具 - C++版本，让你的Windows发光发热！
> Windows 7 以上系统建议使用 Go版本[MikaBooM](https://github.com/MakotoArai-CN/MikaBooM)，更稳定，跨平台能力更强，程序数据更精确。
>
> **⚠免责申明：**
>
> - 🚫本软件仅用于学习交流，请勿用于非法用途。
> - ⚠高强度运算可能导致硬件过热，寿命缩减，请自行承担风险。
## 特性
- ✅ 支持 Windows 2000 到 Windows 11 全系列
- ✅ 单文件可执行程序，无需依赖
- ✅ CPU 和内存使用率实时监控
- ✅ 智能负载调整
- ✅ 系统托盘图标
- ✅ 开机自启动
- ✅ 配置文件支持
## 编译
### 使用 MinGW
> 如果需要支持Windows2000/2003/XP等旧系统，请使用MinGW-w64 4.9.2等旧版本编译。
```bash
make
```
### 重新编译
```bash
make rebuild
```
### 使用 Visual Studio
打开 VS 开发者命令提示符，运行：
```bash
nmake -f Makefile.msvc
```
## 使用
```bash
# 显示帮助
MikaBooM.exe -h
# 设置CPU阈值
MikaBooM.exe -cpu 80
# 设置内存阈值
MikaBooM.exe -mem 70
# 后台运行
MikaBooM.exe -window false
# 启用自启动
MikaBooM.exe -auto
# 禁用自启动
MikaBooM.exe -noauto
```
## 配置文件
程序会在同目录下创建 `config.ini` 文件：
```ini
[General]
cpu_threshold=70
memory_threshold=70
auto_start=true
show_window=true
update_interval=2
[Notification]
enabled=true
cooldown=60
```
## 兼容性
| Windows 版本  | 支持状态 |
| ------------- | -------- |
| Windows 2000  | ✅        |
| Windows XP    | ✅        |
| Windows Vista | ✅        |
| Windows 7     | ✅        |
| Windows 8/8.1 | ✅        |
| Windows 10    | ✅        |
| Windows 11    | ✅        |
## 作者
Makoto
## 许可证
MIT License
## Issues
如果有任何问题，请在 [GitHub Issue](https://github.com/MakotoArai-CN/MikaBooM_CPP/issues) 页面提交。
```

---

## 📝 结束

✅ **全部 26 个文件已展示完毕**

### 统计信息

| 指标 | 数值 |
|------|------|
| 文件总数 | 26 |
| 总行数 | 3,270 |
| 总字符数 | 105,883 |
| 压缩率 | 18.1% |
